{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"components/a_component/","text":"AComponent Introduction Le composant AComponent est une classe de base abstraite qui sert de fondation pour tous les autres composants dans l'ECS. Il fournit une interface commune que tous les composants doivent impl\u00e9menter, assurant ainsi une structure coh\u00e9rente au sein du syst\u00e8me. Attributs Ce composant n'a pas d'attributs sp\u00e9cifiques car il est con\u00e7u pour \u00eatre une classe de base abstraite. Les composants qui en h\u00e9ritent ajouteront leurs propres attributs. R\u00f4le dans l'ECS AComponent est essentiel pour : Uniformiser les composants : Tous les composants partagent une interface commune. Faciliter la gestion des composants : Permet aux entit\u00e9s de stocker et manipuler des composants de mani\u00e8re polymorphique. Exemples d'Utilisation Voici un exemple de d\u00e9finition d'un composant qui h\u00e9rite de AComponent : #include \"AComponent.hpp\" class PositionComponent : public AComponent { public: float x, y; PositionComponent(float x, float y) : x(x), y(y) {} }; Ce mod\u00e8le montre comment des composants comme PositionComponent peuvent \u00eatre construits \u00e0 partir de AComponent pour ajouter leurs propres fonctionnalit\u00e9s et donn\u00e9es. Ce composant abstrait constitue la base de tous les autres et garantit une structure coh\u00e9rente dans le syst\u00e8me ECS.","title":"AComponent"},{"location":"components/a_component/#acomponent","text":"","title":"AComponent"},{"location":"components/a_component/#introduction","text":"Le composant AComponent est une classe de base abstraite qui sert de fondation pour tous les autres composants dans l'ECS. Il fournit une interface commune que tous les composants doivent impl\u00e9menter, assurant ainsi une structure coh\u00e9rente au sein du syst\u00e8me.","title":"Introduction"},{"location":"components/a_component/#attributs","text":"Ce composant n'a pas d'attributs sp\u00e9cifiques car il est con\u00e7u pour \u00eatre une classe de base abstraite. Les composants qui en h\u00e9ritent ajouteront leurs propres attributs.","title":"Attributs"},{"location":"components/a_component/#role-dans-lecs","text":"AComponent est essentiel pour : Uniformiser les composants : Tous les composants partagent une interface commune. Faciliter la gestion des composants : Permet aux entit\u00e9s de stocker et manipuler des composants de mani\u00e8re polymorphique.","title":"R\u00f4le dans l'ECS"},{"location":"components/a_component/#exemples-dutilisation","text":"Voici un exemple de d\u00e9finition d'un composant qui h\u00e9rite de AComponent : #include \"AComponent.hpp\" class PositionComponent : public AComponent { public: float x, y; PositionComponent(float x, float y) : x(x), y(y) {} }; Ce mod\u00e8le montre comment des composants comme PositionComponent peuvent \u00eatre construits \u00e0 partir de AComponent pour ajouter leurs propres fonctionnalit\u00e9s et donn\u00e9es. Ce composant abstrait constitue la base de tous les autres et garantit une structure coh\u00e9rente dans le syst\u00e8me ECS.","title":"Exemples d'Utilisation"},{"location":"components/bullet_id_component/","text":"BulletIdComponent Introduction Le composant BulletIdComponent identifie de mani\u00e8re unique chaque projectile dans le jeu. Il est essentiel pour g\u00e9rer les interactions et le suivi des projectiles sur la carte. Attributs id : Une cha\u00eene de caract\u00e8res unique qui identifie un projectile sp\u00e9cifique. Exemple d'attributs dans le fichier BulletIdComponent.hpp : class BulletIdComponent : public AComponent { public: std::string id; BulletIdComponent(const std::string &id) : id(id) {} }; R\u00f4le dans l'ECS BulletIdComponent est utilis\u00e9 pour : Identifier chaque projectile de mani\u00e8re unique dans le syst\u00e8me. Faciliter la gestion des collisions et des mises \u00e0 jour d'\u00e9tat des projectiles. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &bullet = entityManager.createEntity(); bullet.addComponent<BulletIdComponent>(\"bullet_1234\"); V\u00e9rification des collisions : Lors d'une collision, ce composant peut \u00eatre utilis\u00e9 pour r\u00e9cup\u00e9rer l'ID d'un projectile et appliquer les effets correspondants : cpp auto *bulletId = entity->getComponent<BulletIdComponent>(); if (bulletId) { std::cout << \"Projectile ID : \" << bulletId->id << std::endl; } Interactions Avec PositionComponent : Permet de suivre la position du projectile. Avec VelocityComponent : G\u00e8re la trajectoire du projectile en fonction de sa vitesse. Le composant BulletIdComponent joue un r\u00f4le crucial dans la gestion des projectiles, en offrant un identifiant unique pour chaque instance.","title":"BulletIdComponent"},{"location":"components/bullet_id_component/#bulletidcomponent","text":"","title":"BulletIdComponent"},{"location":"components/bullet_id_component/#introduction","text":"Le composant BulletIdComponent identifie de mani\u00e8re unique chaque projectile dans le jeu. Il est essentiel pour g\u00e9rer les interactions et le suivi des projectiles sur la carte.","title":"Introduction"},{"location":"components/bullet_id_component/#attributs","text":"id : Une cha\u00eene de caract\u00e8res unique qui identifie un projectile sp\u00e9cifique.","title":"Attributs"},{"location":"components/bullet_id_component/#exemple-dattributs-dans-le-fichier-bulletidcomponenthpp","text":"class BulletIdComponent : public AComponent { public: std::string id; BulletIdComponent(const std::string &id) : id(id) {} };","title":"Exemple d'attributs dans le fichier BulletIdComponent.hpp :"},{"location":"components/bullet_id_component/#role-dans-lecs","text":"BulletIdComponent est utilis\u00e9 pour : Identifier chaque projectile de mani\u00e8re unique dans le syst\u00e8me. Faciliter la gestion des collisions et des mises \u00e0 jour d'\u00e9tat des projectiles.","title":"R\u00f4le dans l'ECS"},{"location":"components/bullet_id_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &bullet = entityManager.createEntity(); bullet.addComponent<BulletIdComponent>(\"bullet_1234\"); V\u00e9rification des collisions : Lors d'une collision, ce composant peut \u00eatre utilis\u00e9 pour r\u00e9cup\u00e9rer l'ID d'un projectile et appliquer les effets correspondants : cpp auto *bulletId = entity->getComponent<BulletIdComponent>(); if (bulletId) { std::cout << \"Projectile ID : \" << bulletId->id << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/bullet_id_component/#interactions","text":"Avec PositionComponent : Permet de suivre la position du projectile. Avec VelocityComponent : G\u00e8re la trajectoire du projectile en fonction de sa vitesse. Le composant BulletIdComponent joue un r\u00f4le crucial dans la gestion des projectiles, en offrant un identifiant unique pour chaque instance.","title":"Interactions"},{"location":"components/ennemy_id_component/","text":"EnnemyIdComponent Introduction Le composant EnnemyIdComponent identifie chaque ennemi de mani\u00e8re unique dans le syst\u00e8me. Il est utilis\u00e9 pour distinguer les ennemis et suivre leur \u00e9tat dans le jeu. Attributs id : Une cha\u00eene de caract\u00e8res unique qui repr\u00e9sente l'identifiant de l'ennemi. Exemple d'attributs dans le fichier EnnemyIdComponent.hpp : class EnnemyIdComponent : public AComponent { public: std::string id; EnnemyIdComponent(const std::string &id) : id(id) {} }; R\u00f4le dans l'ECS EnnemyIdComponent est utilis\u00e9 pour : Identifier chaque ennemi de mani\u00e8re unique dans le jeu. Faciliter la gestion des ennemis, comme le suivi de leur \u00e9tat ou l'application des d\u00e9g\u00e2ts. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &enemy = entityManager.createEntity(); enemy.addComponent<EnnemyIdComponent>(\"enemy_001\"); Identification dans un syst\u00e8me : Lors de l'ex\u00e9cution d'un syst\u00e8me, ce composant peut \u00eatre utilis\u00e9 pour identifier les ennemis : cpp auto *enemyId = entity->getComponent<EnnemyIdComponent>(); if (enemyId) { std::cout << \"Enemy ID : \" << enemyId->id << std::endl; } Interactions Avec HealthComponent : Permet de g\u00e9rer les points de vie de l'ennemi. Avec PositionComponent : Suit la position de l'ennemi sur la carte. Avec RenderComponent : G\u00e8re l'affichage de l'ennemi \u00e0 l'\u00e9cran. Le composant EnnemyIdComponent est essentiel pour la gestion des ennemis dans le jeu, offrant un moyen simple de les identifier et de les manipuler.","title":"EnnemyIdComponent"},{"location":"components/ennemy_id_component/#ennemyidcomponent","text":"","title":"EnnemyIdComponent"},{"location":"components/ennemy_id_component/#introduction","text":"Le composant EnnemyIdComponent identifie chaque ennemi de mani\u00e8re unique dans le syst\u00e8me. Il est utilis\u00e9 pour distinguer les ennemis et suivre leur \u00e9tat dans le jeu.","title":"Introduction"},{"location":"components/ennemy_id_component/#attributs","text":"id : Une cha\u00eene de caract\u00e8res unique qui repr\u00e9sente l'identifiant de l'ennemi.","title":"Attributs"},{"location":"components/ennemy_id_component/#exemple-dattributs-dans-le-fichier-ennemyidcomponenthpp","text":"class EnnemyIdComponent : public AComponent { public: std::string id; EnnemyIdComponent(const std::string &id) : id(id) {} };","title":"Exemple d'attributs dans le fichier EnnemyIdComponent.hpp :"},{"location":"components/ennemy_id_component/#role-dans-lecs","text":"EnnemyIdComponent est utilis\u00e9 pour : Identifier chaque ennemi de mani\u00e8re unique dans le jeu. Faciliter la gestion des ennemis, comme le suivi de leur \u00e9tat ou l'application des d\u00e9g\u00e2ts.","title":"R\u00f4le dans l'ECS"},{"location":"components/ennemy_id_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &enemy = entityManager.createEntity(); enemy.addComponent<EnnemyIdComponent>(\"enemy_001\"); Identification dans un syst\u00e8me : Lors de l'ex\u00e9cution d'un syst\u00e8me, ce composant peut \u00eatre utilis\u00e9 pour identifier les ennemis : cpp auto *enemyId = entity->getComponent<EnnemyIdComponent>(); if (enemyId) { std::cout << \"Enemy ID : \" << enemyId->id << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/ennemy_id_component/#interactions","text":"Avec HealthComponent : Permet de g\u00e9rer les points de vie de l'ennemi. Avec PositionComponent : Suit la position de l'ennemi sur la carte. Avec RenderComponent : G\u00e8re l'affichage de l'ennemi \u00e0 l'\u00e9cran. Le composant EnnemyIdComponent est essentiel pour la gestion des ennemis dans le jeu, offrant un moyen simple de les identifier et de les manipuler.","title":"Interactions"},{"location":"components/event_handler_component/","text":"EventHandlerComponent Introduction Le composant EventHandlerComponent permet de g\u00e9rer les \u00e9v\u00e9nements associ\u00e9s \u00e0 une entit\u00e9. Il permet de d\u00e9finir des callbacks qui sont ex\u00e9cut\u00e9s en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements sp\u00e9cifiques, tels que les clics de souris ou les pressions de touches. Attributs callbacks : Une table associant un type d'\u00e9v\u00e9nement ( sf::Event::EventType ) \u00e0 une fonction de callback. Exemple d'attributs dans le fichier EventHandlerComponent.hpp : #include <SFML/Window/Event.hpp> #include <unordered_map> #include <functional> class EventHandlerComponent : public AComponent { public: using callbackFunction = std::function<void(const sf::Event &)>; std::unordered_map<sf::Event::EventType, callbackFunction> callbacks; EventHandlerComponent(sf::Event::EventType eventType, callbackFunction callback) { callbacks[eventType] = callback; } void setCallback(sf::Event::EventType eventType, callbackFunction callback) { callbacks[eventType] = callback; } }; R\u00f4le dans l'ECS EventHandlerComponent est utilis\u00e9 pour : Associer des \u00e9v\u00e9nements \u00e0 des actions sp\u00e9cifiques sur une entit\u00e9. Fournir une gestion flexible des interactions utilisateur. Permettre une r\u00e9action contextuelle des entit\u00e9s aux \u00e9v\u00e9nements du jeu. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<EventHandlerComponent>(sf::Event::MouseButtonPressed, [](const sf::Event &event) { std::cout << \"Bouton cliqu\u00e9 !\" << std::endl; }); Modification des callbacks : cpp auto *eventHandler = entity.getComponent<EventHandlerComponent>(); if (eventHandler) { eventHandler->setCallback(sf::Event::KeyPressed, [](const sf::Event &event) { std::cout << \"Touche press\u00e9e !\" << std::endl; }); } Interactions Avec EventHandlingSystem : Le syst\u00e8me ex\u00e9cute les callbacks d\u00e9finis dans ce composant pour chaque \u00e9v\u00e9nement d\u00e9tect\u00e9. Avec HoverComponent : Peut \u00eatre utilis\u00e9 pour d\u00e9clencher des \u00e9v\u00e9nements en r\u00e9ponse au survol de la souris. Le composant EventHandlerComponent est essentiel pour la gestion des interactions utilisateur dans le jeu, offrant une flexibilit\u00e9 pour associer des \u00e9v\u00e9nements \u00e0 des comportements sp\u00e9cifiques.","title":"EventHandlerComponent"},{"location":"components/event_handler_component/#eventhandlercomponent","text":"","title":"EventHandlerComponent"},{"location":"components/event_handler_component/#introduction","text":"Le composant EventHandlerComponent permet de g\u00e9rer les \u00e9v\u00e9nements associ\u00e9s \u00e0 une entit\u00e9. Il permet de d\u00e9finir des callbacks qui sont ex\u00e9cut\u00e9s en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements sp\u00e9cifiques, tels que les clics de souris ou les pressions de touches.","title":"Introduction"},{"location":"components/event_handler_component/#attributs","text":"callbacks : Une table associant un type d'\u00e9v\u00e9nement ( sf::Event::EventType ) \u00e0 une fonction de callback.","title":"Attributs"},{"location":"components/event_handler_component/#exemple-dattributs-dans-le-fichier-eventhandlercomponenthpp","text":"#include <SFML/Window/Event.hpp> #include <unordered_map> #include <functional> class EventHandlerComponent : public AComponent { public: using callbackFunction = std::function<void(const sf::Event &)>; std::unordered_map<sf::Event::EventType, callbackFunction> callbacks; EventHandlerComponent(sf::Event::EventType eventType, callbackFunction callback) { callbacks[eventType] = callback; } void setCallback(sf::Event::EventType eventType, callbackFunction callback) { callbacks[eventType] = callback; } };","title":"Exemple d'attributs dans le fichier EventHandlerComponent.hpp :"},{"location":"components/event_handler_component/#role-dans-lecs","text":"EventHandlerComponent est utilis\u00e9 pour : Associer des \u00e9v\u00e9nements \u00e0 des actions sp\u00e9cifiques sur une entit\u00e9. Fournir une gestion flexible des interactions utilisateur. Permettre une r\u00e9action contextuelle des entit\u00e9s aux \u00e9v\u00e9nements du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"components/event_handler_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<EventHandlerComponent>(sf::Event::MouseButtonPressed, [](const sf::Event &event) { std::cout << \"Bouton cliqu\u00e9 !\" << std::endl; }); Modification des callbacks : cpp auto *eventHandler = entity.getComponent<EventHandlerComponent>(); if (eventHandler) { eventHandler->setCallback(sf::Event::KeyPressed, [](const sf::Event &event) { std::cout << \"Touche press\u00e9e !\" << std::endl; }); }","title":"Exemples d'Utilisation"},{"location":"components/event_handler_component/#interactions","text":"Avec EventHandlingSystem : Le syst\u00e8me ex\u00e9cute les callbacks d\u00e9finis dans ce composant pour chaque \u00e9v\u00e9nement d\u00e9tect\u00e9. Avec HoverComponent : Peut \u00eatre utilis\u00e9 pour d\u00e9clencher des \u00e9v\u00e9nements en r\u00e9ponse au survol de la souris. Le composant EventHandlerComponent est essentiel pour la gestion des interactions utilisateur dans le jeu, offrant une flexibilit\u00e9 pour associer des \u00e9v\u00e9nements \u00e0 des comportements sp\u00e9cifiques.","title":"Interactions"},{"location":"components/health_component/","text":"HealthComponent Introduction Le composant HealthComponent est utilis\u00e9 pour g\u00e9rer les points de vie des entit\u00e9s dans le jeu. Il permet de suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s et de d\u00e9terminer si elles sont vivantes ou doivent \u00eatre supprim\u00e9es. Attributs health : Un entier repr\u00e9sentant les points de vie actuels de l'entit\u00e9. maxHealth : Un entier repr\u00e9sentant le nombre maximum de points de vie que l'entit\u00e9 peut avoir. Exemple d'attributs dans le fichier HealthComponent.hpp : class HealthComponent : public AComponent { public: int health; int maxHealth; HealthComponent(int health, int maxHealth) : health(health), maxHealth(maxHealth) {} }; R\u00f4le dans l'ECS HealthComponent est utilis\u00e9 pour : Suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s, telles que les joueurs, ennemis ou objets destructibles. D\u00e9clencher des \u00e9v\u00e9nements lorsque la sant\u00e9 atteint 0 (par exemple, destruction ou mort). G\u00e9rer les soins ou autres modifications des points de vie. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<HealthComponent>(100, 100); R\u00e9duction des points de vie : cpp auto *health = entity->getComponent<HealthComponent>(); if (health) { health->health -= 10; if (health->health <= 0) { entityManager.markForDeletion(entity->getId()); } } Soin d'une entit\u00e9 : cpp if (health && health->health < health->maxHealth) { health->health += 20; if (health->health > health->maxHealth) { health->health = health->maxHealth; } } Interactions Avec RenderComponent : Pour afficher une barre de vie ou d'autres indicateurs visuels. Avec MessageSystem : Pour synchroniser l'\u00e9tat de sant\u00e9 entre les clients et le serveur. Le composant HealthComponent est un \u00e9l\u00e9ment cl\u00e9 pour g\u00e9rer l'\u00e9tat des entit\u00e9s dans le jeu, permettant des interactions dynamiques et r\u00e9actives bas\u00e9es sur leur sant\u00e9.","title":"HealthComponent"},{"location":"components/health_component/#healthcomponent","text":"","title":"HealthComponent"},{"location":"components/health_component/#introduction","text":"Le composant HealthComponent est utilis\u00e9 pour g\u00e9rer les points de vie des entit\u00e9s dans le jeu. Il permet de suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s et de d\u00e9terminer si elles sont vivantes ou doivent \u00eatre supprim\u00e9es.","title":"Introduction"},{"location":"components/health_component/#attributs","text":"health : Un entier repr\u00e9sentant les points de vie actuels de l'entit\u00e9. maxHealth : Un entier repr\u00e9sentant le nombre maximum de points de vie que l'entit\u00e9 peut avoir.","title":"Attributs"},{"location":"components/health_component/#exemple-dattributs-dans-le-fichier-healthcomponenthpp","text":"class HealthComponent : public AComponent { public: int health; int maxHealth; HealthComponent(int health, int maxHealth) : health(health), maxHealth(maxHealth) {} };","title":"Exemple d'attributs dans le fichier HealthComponent.hpp :"},{"location":"components/health_component/#role-dans-lecs","text":"HealthComponent est utilis\u00e9 pour : Suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s, telles que les joueurs, ennemis ou objets destructibles. D\u00e9clencher des \u00e9v\u00e9nements lorsque la sant\u00e9 atteint 0 (par exemple, destruction ou mort). G\u00e9rer les soins ou autres modifications des points de vie.","title":"R\u00f4le dans l'ECS"},{"location":"components/health_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<HealthComponent>(100, 100); R\u00e9duction des points de vie : cpp auto *health = entity->getComponent<HealthComponent>(); if (health) { health->health -= 10; if (health->health <= 0) { entityManager.markForDeletion(entity->getId()); } } Soin d'une entit\u00e9 : cpp if (health && health->health < health->maxHealth) { health->health += 20; if (health->health > health->maxHealth) { health->health = health->maxHealth; } }","title":"Exemples d'Utilisation"},{"location":"components/health_component/#interactions","text":"Avec RenderComponent : Pour afficher une barre de vie ou d'autres indicateurs visuels. Avec MessageSystem : Pour synchroniser l'\u00e9tat de sant\u00e9 entre les clients et le serveur. Le composant HealthComponent est un \u00e9l\u00e9ment cl\u00e9 pour g\u00e9rer l'\u00e9tat des entit\u00e9s dans le jeu, permettant des interactions dynamiques et r\u00e9actives bas\u00e9es sur leur sant\u00e9.","title":"Interactions"},{"location":"components/hover_component/","text":"HoverComponent Introduction Le composant HoverComponent est utilis\u00e9 pour g\u00e9rer les interactions visuelles lorsque la souris survole une entit\u00e9. Il permet de changer l'apparence d'une entit\u00e9, telle que sa couleur, lorsqu'elle est survol\u00e9e. Attributs defaultColor : La couleur par d\u00e9faut de l'entit\u00e9. hoverColor : La couleur affich\u00e9e lorsque la souris survole l'entit\u00e9. Exemple d'attributs dans le fichier HoverComponent.hpp : #include <SFML/Graphics/Color.hpp> class HoverComponent : public AComponent { public: sf::Color defaultColor; sf::Color hoverColor; HoverComponent(const sf::Color &defaultColor, const sf::Color &hoverColor) : defaultColor(defaultColor), hoverColor(hoverColor) {} }; R\u00f4le dans l'ECS HoverComponent est utilis\u00e9 pour : D\u00e9tecter les interactions de la souris avec une entit\u00e9. Modifier visuellement une entit\u00e9 pour indiquer qu'elle est survol\u00e9e. Am\u00e9liorer l'exp\u00e9rience utilisateur en offrant des retours visuels imm\u00e9diats. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<HoverComponent>(sf::Color::White, sf::Color::Red); Modification des couleurs : cpp auto *hover = entity.getComponent<HoverComponent>(); if (hover) { hover->defaultColor = sf::Color::Blue; hover->hoverColor = sf::Color::Green; } Interactions Avec HoverSystem : Le syst\u00e8me applique les changements de couleur d\u00e9finis dans le composant en fonction de la position de la souris. Avec RectangleShapeComponent et SpriteComponent : Les couleurs d\u00e9finies dans HoverComponent sont appliqu\u00e9es aux formes ou sprites associ\u00e9s. Fonctionnalit\u00e9s principales Gestion du survol Le composant travaille en tandem avec HoverSystem pour d\u00e9tecter si la souris est au-dessus d'une entit\u00e9. En fonction de cette d\u00e9tection, il applique soit la couleur par d\u00e9faut, soit la couleur de survol. Le composant HoverComponent ajoute une couche d'interactivit\u00e9 visuelle, essentielle pour des \u00e9l\u00e9ments tels que les boutons ou les entit\u00e9s interactives dans le jeu.","title":"HoverComponent"},{"location":"components/hover_component/#hovercomponent","text":"","title":"HoverComponent"},{"location":"components/hover_component/#introduction","text":"Le composant HoverComponent est utilis\u00e9 pour g\u00e9rer les interactions visuelles lorsque la souris survole une entit\u00e9. Il permet de changer l'apparence d'une entit\u00e9, telle que sa couleur, lorsqu'elle est survol\u00e9e.","title":"Introduction"},{"location":"components/hover_component/#attributs","text":"defaultColor : La couleur par d\u00e9faut de l'entit\u00e9. hoverColor : La couleur affich\u00e9e lorsque la souris survole l'entit\u00e9.","title":"Attributs"},{"location":"components/hover_component/#exemple-dattributs-dans-le-fichier-hovercomponenthpp","text":"#include <SFML/Graphics/Color.hpp> class HoverComponent : public AComponent { public: sf::Color defaultColor; sf::Color hoverColor; HoverComponent(const sf::Color &defaultColor, const sf::Color &hoverColor) : defaultColor(defaultColor), hoverColor(hoverColor) {} };","title":"Exemple d'attributs dans le fichier HoverComponent.hpp :"},{"location":"components/hover_component/#role-dans-lecs","text":"HoverComponent est utilis\u00e9 pour : D\u00e9tecter les interactions de la souris avec une entit\u00e9. Modifier visuellement une entit\u00e9 pour indiquer qu'elle est survol\u00e9e. Am\u00e9liorer l'exp\u00e9rience utilisateur en offrant des retours visuels imm\u00e9diats.","title":"R\u00f4le dans l'ECS"},{"location":"components/hover_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<HoverComponent>(sf::Color::White, sf::Color::Red); Modification des couleurs : cpp auto *hover = entity.getComponent<HoverComponent>(); if (hover) { hover->defaultColor = sf::Color::Blue; hover->hoverColor = sf::Color::Green; }","title":"Exemples d'Utilisation"},{"location":"components/hover_component/#interactions","text":"Avec HoverSystem : Le syst\u00e8me applique les changements de couleur d\u00e9finis dans le composant en fonction de la position de la souris. Avec RectangleShapeComponent et SpriteComponent : Les couleurs d\u00e9finies dans HoverComponent sont appliqu\u00e9es aux formes ou sprites associ\u00e9s.","title":"Interactions"},{"location":"components/hover_component/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"components/hover_component/#gestion-du-survol","text":"Le composant travaille en tandem avec HoverSystem pour d\u00e9tecter si la souris est au-dessus d'une entit\u00e9. En fonction de cette d\u00e9tection, il applique soit la couleur par d\u00e9faut, soit la couleur de survol. Le composant HoverComponent ajoute une couche d'interactivit\u00e9 visuelle, essentielle pour des \u00e9l\u00e9ments tels que les boutons ou les entit\u00e9s interactives dans le jeu.","title":"Gestion du survol"},{"location":"components/input_component/","text":"InputComponent Introduction Le composant InputComponent g\u00e8re les entr\u00e9es utilisateur associ\u00e9es \u00e0 une entit\u00e9 sp\u00e9cifique. Il permet de capturer et de traiter les actions comme le d\u00e9placement, les tirs ou d'autres commandes. Attributs moveLeft : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement \u00e0 gauche. moveRight : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement \u00e0 droite. moveUp : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement vers le haut. moveDown : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement vers le bas. spaceBar : Bool\u00e9en indiquant si l'utilisateur presse la barre d'espace. Exemple d'attributs dans le fichier InputComponent.hpp : class InputComponent : public AComponent { public: bool moveLeft = false; bool moveRight = false; bool moveUp = false; bool moveDown = false; bool spaceBar = false; }; R\u00f4le dans l'ECS InputComponent est utilis\u00e9 pour : Capturer les entr\u00e9es utilisateur et les associer \u00e0 une entit\u00e9 donn\u00e9e. Permettre aux syst\u00e8mes (comme InputSystem ) de traduire ces entr\u00e9es en actions concr\u00e8tes dans le jeu. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<InputComponent>(); Traitement des entr\u00e9es : Utilis\u00e9 dans InputSystem pour mettre \u00e0 jour les \u00e9tats des composants : cpp void InputSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *input = entity->getComponent<InputComponent>(); if (input) { input->moveLeft = sf::Keyboard::isKeyPressed(sf::Keyboard::Left); input->moveRight = sf::Keyboard::isKeyPressed(sf::Keyboard::Right); input->moveUp = sf::Keyboard::isKeyPressed(sf::Keyboard::Up); input->moveDown = sf::Keyboard::isKeyPressed(sf::Keyboard::Down); input->spaceBar = sf::Keyboard::isKeyPressed(sf::Keyboard::Space); } } } Interactions Avec MovementSystem : Traduit les entr\u00e9es utilisateur en d\u00e9placements d'entit\u00e9s. Avec NetworkManager : Synchronise les commandes utilisateur avec le serveur pour un jeu en r\u00e9seau. Le composant InputComponent est crucial pour connecter les actions des joueurs aux entit\u00e9s dans le jeu, en traduisant les entr\u00e9es utilisateur en modifications d'\u00e9tat concr\u00e8tes.","title":"InputComponent"},{"location":"components/input_component/#inputcomponent","text":"","title":"InputComponent"},{"location":"components/input_component/#introduction","text":"Le composant InputComponent g\u00e8re les entr\u00e9es utilisateur associ\u00e9es \u00e0 une entit\u00e9 sp\u00e9cifique. Il permet de capturer et de traiter les actions comme le d\u00e9placement, les tirs ou d'autres commandes.","title":"Introduction"},{"location":"components/input_component/#attributs","text":"moveLeft : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement \u00e0 gauche. moveRight : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement \u00e0 droite. moveUp : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement vers le haut. moveDown : Bool\u00e9en indiquant si l'utilisateur presse la touche de d\u00e9placement vers le bas. spaceBar : Bool\u00e9en indiquant si l'utilisateur presse la barre d'espace.","title":"Attributs"},{"location":"components/input_component/#exemple-dattributs-dans-le-fichier-inputcomponenthpp","text":"class InputComponent : public AComponent { public: bool moveLeft = false; bool moveRight = false; bool moveUp = false; bool moveDown = false; bool spaceBar = false; };","title":"Exemple d'attributs dans le fichier InputComponent.hpp :"},{"location":"components/input_component/#role-dans-lecs","text":"InputComponent est utilis\u00e9 pour : Capturer les entr\u00e9es utilisateur et les associer \u00e0 une entit\u00e9 donn\u00e9e. Permettre aux syst\u00e8mes (comme InputSystem ) de traduire ces entr\u00e9es en actions concr\u00e8tes dans le jeu.","title":"R\u00f4le dans l'ECS"},{"location":"components/input_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<InputComponent>(); Traitement des entr\u00e9es : Utilis\u00e9 dans InputSystem pour mettre \u00e0 jour les \u00e9tats des composants : cpp void InputSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *input = entity->getComponent<InputComponent>(); if (input) { input->moveLeft = sf::Keyboard::isKeyPressed(sf::Keyboard::Left); input->moveRight = sf::Keyboard::isKeyPressed(sf::Keyboard::Right); input->moveUp = sf::Keyboard::isKeyPressed(sf::Keyboard::Up); input->moveDown = sf::Keyboard::isKeyPressed(sf::Keyboard::Down); input->spaceBar = sf::Keyboard::isKeyPressed(sf::Keyboard::Space); } } }","title":"Exemples d'Utilisation"},{"location":"components/input_component/#interactions","text":"Avec MovementSystem : Traduit les entr\u00e9es utilisateur en d\u00e9placements d'entit\u00e9s. Avec NetworkManager : Synchronise les commandes utilisateur avec le serveur pour un jeu en r\u00e9seau. Le composant InputComponent est crucial pour connecter les actions des joueurs aux entit\u00e9s dans le jeu, en traduisant les entr\u00e9es utilisateur en modifications d'\u00e9tat concr\u00e8tes.","title":"Interactions"},{"location":"components/network_component/","text":"NetworkComponent Introduction Le composant NetworkComponent g\u00e8re les informations r\u00e9seau associ\u00e9es \u00e0 une entit\u00e9, telles que l'identifiant utilisateur ou d'autres donn\u00e9es n\u00e9cessaires pour la synchronisation entre le client et le serveur. Attributs username : Une cha\u00eene de caract\u00e8res repr\u00e9sentant l'identifiant unique de l'utilisateur. Exemple d'attributs dans le fichier NetworkComponent.hpp : class NetworkComponent : public AComponent { public: std::string username; NetworkComponent(const std::string &username) : username(username) {} }; R\u00f4le dans l'ECS NetworkComponent est utilis\u00e9 pour : Associer un identifiant r\u00e9seau unique \u00e0 une entit\u00e9. Faciliter la synchronisation des entit\u00e9s entre les diff\u00e9rents clients et le serveur. Identifier les actions et \u00e9v\u00e9nements li\u00e9s \u00e0 un utilisateur particulier. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<NetworkComponent>(\"player_1\"); Utilisation dans un syst\u00e8me : Dans un syst\u00e8me comme MessageSystem , le composant peut \u00eatre utilis\u00e9 pour identifier et mettre \u00e0 jour les entit\u00e9s correspondantes : cpp auto *network = entity->getComponent<NetworkComponent>(); if (network) { std::cout << \"Synchronisation pour l'utilisateur : \" << network->username << std::endl; } Interactions Avec MessageSystem : Utilis\u00e9 pour synchroniser l'\u00e9tat des entit\u00e9s \u00e0 travers le r\u00e9seau. Avec InputComponent : Relie les commandes d'un utilisateur aux entit\u00e9s sp\u00e9cifiques. Avec PositionComponent : G\u00e8re la mise \u00e0 jour de la position d'une entit\u00e9 sur le r\u00e9seau. Le composant NetworkComponent est essentiel pour g\u00e9rer la communication et la synchronisation r\u00e9seau, garantissant que chaque utilisateur interagit correctement avec le jeu dans un environnement multijoueur.","title":"NetworkComponent"},{"location":"components/network_component/#networkcomponent","text":"","title":"NetworkComponent"},{"location":"components/network_component/#introduction","text":"Le composant NetworkComponent g\u00e8re les informations r\u00e9seau associ\u00e9es \u00e0 une entit\u00e9, telles que l'identifiant utilisateur ou d'autres donn\u00e9es n\u00e9cessaires pour la synchronisation entre le client et le serveur.","title":"Introduction"},{"location":"components/network_component/#attributs","text":"username : Une cha\u00eene de caract\u00e8res repr\u00e9sentant l'identifiant unique de l'utilisateur.","title":"Attributs"},{"location":"components/network_component/#exemple-dattributs-dans-le-fichier-networkcomponenthpp","text":"class NetworkComponent : public AComponent { public: std::string username; NetworkComponent(const std::string &username) : username(username) {} };","title":"Exemple d'attributs dans le fichier NetworkComponent.hpp :"},{"location":"components/network_component/#role-dans-lecs","text":"NetworkComponent est utilis\u00e9 pour : Associer un identifiant r\u00e9seau unique \u00e0 une entit\u00e9. Faciliter la synchronisation des entit\u00e9s entre les diff\u00e9rents clients et le serveur. Identifier les actions et \u00e9v\u00e9nements li\u00e9s \u00e0 un utilisateur particulier.","title":"R\u00f4le dans l'ECS"},{"location":"components/network_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<NetworkComponent>(\"player_1\"); Utilisation dans un syst\u00e8me : Dans un syst\u00e8me comme MessageSystem , le composant peut \u00eatre utilis\u00e9 pour identifier et mettre \u00e0 jour les entit\u00e9s correspondantes : cpp auto *network = entity->getComponent<NetworkComponent>(); if (network) { std::cout << \"Synchronisation pour l'utilisateur : \" << network->username << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/network_component/#interactions","text":"Avec MessageSystem : Utilis\u00e9 pour synchroniser l'\u00e9tat des entit\u00e9s \u00e0 travers le r\u00e9seau. Avec InputComponent : Relie les commandes d'un utilisateur aux entit\u00e9s sp\u00e9cifiques. Avec PositionComponent : G\u00e8re la mise \u00e0 jour de la position d'une entit\u00e9 sur le r\u00e9seau. Le composant NetworkComponent est essentiel pour g\u00e9rer la communication et la synchronisation r\u00e9seau, garantissant que chaque utilisateur interagit correctement avec le jeu dans un environnement multijoueur.","title":"Interactions"},{"location":"components/parallax_component/","text":"ParallaxComponent Introduction Le composant ParallaxComponent est utilis\u00e9 pour cr\u00e9er des effets de d\u00e9filement parallaxe dans le jeu. Il permet d'ajouter de la profondeur visuelle en d\u00e9pla\u00e7ant des textures ou des images \u00e0 diff\u00e9rentes vitesses. Attributs texture : La texture utilis\u00e9e pour l'effet de parallaxe. sprite : Un sprite associ\u00e9 \u00e0 la texture. position : La position actuelle du parallaxe. scale : Le facteur d'\u00e9chelle appliqu\u00e9 \u00e0 la texture. speed : La vitesse de d\u00e9filement sur les axes X et Y. Exemple d'attributs dans le fichier ParallaxComponent.hpp : #include <SFML/Graphics/Texture.hpp> #include <SFML/Graphics/Sprite.hpp> #include <SFML/System/Vector2.hpp> class ParallaxComponent : public AComponent { public: sf::Texture texture; sf::Sprite sprite; sf::Vector2f position; sf::Vector2f scale; sf::Vector2f speed; ParallaxComponent(const std::string &texturePath, const sf::Vector2f &scale, const sf::Vector2f &speed) : scale(scale), speed(speed) { if (!texture.loadFromFile(texturePath)) { throw std::runtime_error(\"Failed to load texture: \" + texturePath); } sprite.setTexture(texture); sprite.setScale(scale); } }; R\u00f4le dans l'ECS ParallaxComponent est utilis\u00e9 pour : Ajouter des arri\u00e8re-plans ou des \u00e9l\u00e9ments d\u00e9coratifs avec des effets de d\u00e9filement parallaxe. Cr\u00e9er une profondeur visuelle dans le jeu. Synchroniser le mouvement du parallaxe avec les actions ou \u00e9v\u00e9nements du jeu. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &background = entityManager.createEntity(); background.addComponent<ParallaxComponent>(\"assets/background.png\", sf::Vector2f(1.0f, 1.0f), sf::Vector2f(-50.0f, 0.0f)); Modification des propri\u00e9t\u00e9s : cpp auto *parallax = entity.getComponent<ParallaxComponent>(); if (parallax) { parallax->speed = sf::Vector2f(-30.0f, 0.0f); } Interactions Avec ParallaxSystem : Le syst\u00e8me met \u00e0 jour les positions des composants parallaxe en fonction de la vitesse et du temps \u00e9coul\u00e9. Avec RenderSystem : Affiche les sprites parallaxe sur l'\u00e9cran. Fonctionnalit\u00e9s principales Effet de d\u00e9filement Le composant fonctionne en tandem avec ParallaxSystem pour d\u00e9placer la texture de mani\u00e8re fluide, en cr\u00e9ant un effet de continuit\u00e9 visuelle m\u00eame lorsque la texture sort de l'\u00e9cran. Le composant ParallaxComponent est id\u00e9al pour enrichir l'exp\u00e9rience visuelle du joueur, en apportant des \u00e9l\u00e9ments d\u00e9coratifs dynamiques et immersifs.","title":"ParallaxComponent"},{"location":"components/parallax_component/#parallaxcomponent","text":"","title":"ParallaxComponent"},{"location":"components/parallax_component/#introduction","text":"Le composant ParallaxComponent est utilis\u00e9 pour cr\u00e9er des effets de d\u00e9filement parallaxe dans le jeu. Il permet d'ajouter de la profondeur visuelle en d\u00e9pla\u00e7ant des textures ou des images \u00e0 diff\u00e9rentes vitesses.","title":"Introduction"},{"location":"components/parallax_component/#attributs","text":"texture : La texture utilis\u00e9e pour l'effet de parallaxe. sprite : Un sprite associ\u00e9 \u00e0 la texture. position : La position actuelle du parallaxe. scale : Le facteur d'\u00e9chelle appliqu\u00e9 \u00e0 la texture. speed : La vitesse de d\u00e9filement sur les axes X et Y.","title":"Attributs"},{"location":"components/parallax_component/#exemple-dattributs-dans-le-fichier-parallaxcomponenthpp","text":"#include <SFML/Graphics/Texture.hpp> #include <SFML/Graphics/Sprite.hpp> #include <SFML/System/Vector2.hpp> class ParallaxComponent : public AComponent { public: sf::Texture texture; sf::Sprite sprite; sf::Vector2f position; sf::Vector2f scale; sf::Vector2f speed; ParallaxComponent(const std::string &texturePath, const sf::Vector2f &scale, const sf::Vector2f &speed) : scale(scale), speed(speed) { if (!texture.loadFromFile(texturePath)) { throw std::runtime_error(\"Failed to load texture: \" + texturePath); } sprite.setTexture(texture); sprite.setScale(scale); } };","title":"Exemple d'attributs dans le fichier ParallaxComponent.hpp :"},{"location":"components/parallax_component/#role-dans-lecs","text":"ParallaxComponent est utilis\u00e9 pour : Ajouter des arri\u00e8re-plans ou des \u00e9l\u00e9ments d\u00e9coratifs avec des effets de d\u00e9filement parallaxe. Cr\u00e9er une profondeur visuelle dans le jeu. Synchroniser le mouvement du parallaxe avec les actions ou \u00e9v\u00e9nements du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"components/parallax_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &background = entityManager.createEntity(); background.addComponent<ParallaxComponent>(\"assets/background.png\", sf::Vector2f(1.0f, 1.0f), sf::Vector2f(-50.0f, 0.0f)); Modification des propri\u00e9t\u00e9s : cpp auto *parallax = entity.getComponent<ParallaxComponent>(); if (parallax) { parallax->speed = sf::Vector2f(-30.0f, 0.0f); }","title":"Exemples d'Utilisation"},{"location":"components/parallax_component/#interactions","text":"Avec ParallaxSystem : Le syst\u00e8me met \u00e0 jour les positions des composants parallaxe en fonction de la vitesse et du temps \u00e9coul\u00e9. Avec RenderSystem : Affiche les sprites parallaxe sur l'\u00e9cran.","title":"Interactions"},{"location":"components/parallax_component/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"components/parallax_component/#effet-de-defilement","text":"Le composant fonctionne en tandem avec ParallaxSystem pour d\u00e9placer la texture de mani\u00e8re fluide, en cr\u00e9ant un effet de continuit\u00e9 visuelle m\u00eame lorsque la texture sort de l'\u00e9cran. Le composant ParallaxComponent est id\u00e9al pour enrichir l'exp\u00e9rience visuelle du joueur, en apportant des \u00e9l\u00e9ments d\u00e9coratifs dynamiques et immersifs.","title":"Effet de d\u00e9filement"},{"location":"components/position_component/","text":"PositionComponent Introduction Le composant PositionComponent est utilis\u00e9 pour stocker et g\u00e9rer la position spatiale d'une entit\u00e9 dans le monde du jeu. Il est fondamental pour toute entit\u00e9 ayant une repr\u00e9sentation physique ou graphique. Attributs position : Un vecteur 2D (souvent repr\u00e9sent\u00e9 par sf::Vector2f ou une structure \u00e9quivalente) contenant les coordonn\u00e9es X et Y de l'entit\u00e9. Exemple d'attributs dans le fichier PositionComponent.hpp : #include <SFML/System/Vector2.hpp> class PositionComponent : public AComponent { public: sf::Vector2f position; PositionComponent(float x, float y) : position(x, y) {} }; R\u00f4le dans l'ECS PositionComponent est utilis\u00e9 pour : D\u00e9finir et suivre la position d'une entit\u00e9 sur la carte. Permettre aux syst\u00e8mes comme MovementSystem et RenderSystem d'acc\u00e9der \u00e0 la position de l'entit\u00e9. Servir de base pour des calculs tels que les collisions ou les distances entre entit\u00e9s. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<PositionComponent>(100.0f, 200.0f); Mise \u00e0 jour de la position : Utilis\u00e9 dans un syst\u00e8me tel que MovementSystem : cpp auto *position = entity->getComponent<PositionComponent>(); if (position) { position->position.x += 10.0f; position->position.y += 5.0f; } Acc\u00e8s \u00e0 la position : Dans un syst\u00e8me de rendu ou de collision : cpp auto *position = entity->getComponent<PositionComponent>(); if (position) { std::cout << \"Position actuelle : (\" << position->position.x << \", \" << position->position.y << \")\" << std::endl; } Interactions Avec MovementSystem : Permet la mise \u00e0 jour des coordonn\u00e9es en fonction des vitesses et des entr\u00e9es utilisateur. Avec RenderSystem : Utilis\u00e9 pour d\u00e9terminer o\u00f9 dessiner les entit\u00e9s sur l'\u00e9cran. Avec CollisionSystem : \u00c9valu\u00e9 pour d\u00e9tecter les chevauchements ou interactions entre entit\u00e9s. Le composant PositionComponent est un \u00e9l\u00e9ment essentiel dans tout jeu, fournissant les coordonn\u00e9es n\u00e9cessaires pour toutes les op\u00e9rations spatiales.","title":"PositionComponent"},{"location":"components/position_component/#positioncomponent","text":"","title":"PositionComponent"},{"location":"components/position_component/#introduction","text":"Le composant PositionComponent est utilis\u00e9 pour stocker et g\u00e9rer la position spatiale d'une entit\u00e9 dans le monde du jeu. Il est fondamental pour toute entit\u00e9 ayant une repr\u00e9sentation physique ou graphique.","title":"Introduction"},{"location":"components/position_component/#attributs","text":"position : Un vecteur 2D (souvent repr\u00e9sent\u00e9 par sf::Vector2f ou une structure \u00e9quivalente) contenant les coordonn\u00e9es X et Y de l'entit\u00e9.","title":"Attributs"},{"location":"components/position_component/#exemple-dattributs-dans-le-fichier-positioncomponenthpp","text":"#include <SFML/System/Vector2.hpp> class PositionComponent : public AComponent { public: sf::Vector2f position; PositionComponent(float x, float y) : position(x, y) {} };","title":"Exemple d'attributs dans le fichier PositionComponent.hpp :"},{"location":"components/position_component/#role-dans-lecs","text":"PositionComponent est utilis\u00e9 pour : D\u00e9finir et suivre la position d'une entit\u00e9 sur la carte. Permettre aux syst\u00e8mes comme MovementSystem et RenderSystem d'acc\u00e9der \u00e0 la position de l'entit\u00e9. Servir de base pour des calculs tels que les collisions ou les distances entre entit\u00e9s.","title":"R\u00f4le dans l'ECS"},{"location":"components/position_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<PositionComponent>(100.0f, 200.0f); Mise \u00e0 jour de la position : Utilis\u00e9 dans un syst\u00e8me tel que MovementSystem : cpp auto *position = entity->getComponent<PositionComponent>(); if (position) { position->position.x += 10.0f; position->position.y += 5.0f; } Acc\u00e8s \u00e0 la position : Dans un syst\u00e8me de rendu ou de collision : cpp auto *position = entity->getComponent<PositionComponent>(); if (position) { std::cout << \"Position actuelle : (\" << position->position.x << \", \" << position->position.y << \")\" << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/position_component/#interactions","text":"Avec MovementSystem : Permet la mise \u00e0 jour des coordonn\u00e9es en fonction des vitesses et des entr\u00e9es utilisateur. Avec RenderSystem : Utilis\u00e9 pour d\u00e9terminer o\u00f9 dessiner les entit\u00e9s sur l'\u00e9cran. Avec CollisionSystem : \u00c9valu\u00e9 pour d\u00e9tecter les chevauchements ou interactions entre entit\u00e9s. Le composant PositionComponent est un \u00e9l\u00e9ment essentiel dans tout jeu, fournissant les coordonn\u00e9es n\u00e9cessaires pour toutes les op\u00e9rations spatiales.","title":"Interactions"},{"location":"components/rectangle_shape/","text":"RectangleShapeComponent Introduction Le composant RectangleShapeComponent est utilis\u00e9 pour repr\u00e9senter des entit\u00e9s sous forme de rectangles graphiques dans le jeu. Il permet de d\u00e9finir l'apparence et la position d'une entit\u00e9 en utilisant un rectangle SFML. Attributs shape : Un objet sf::RectangleShape repr\u00e9sentant le rectangle graphique. Exemple d'attributs dans le fichier RectangleShapeComponent.hpp : #include <SFML/Graphics/RectangleShape.hpp> #include <SFML/System/Vector2.hpp> #include <SFML/Graphics/Color.hpp> class RectangleShapeComponent : public AComponent { public: sf::RectangleShape shape; RectangleShapeComponent(const sf::Vector2f &size, const sf::Vector2f &position, const sf::Color &color) { shape.setSize(size); shape.setPosition(position); shape.setFillColor(color); } }; R\u00f4le dans l'ECS RectangleShapeComponent est utilis\u00e9 pour : Afficher des entit\u00e9s sous forme de rectangles. D\u00e9finir des propri\u00e9t\u00e9s graphiques comme la taille, la couleur et la position. Fournir une base pour des interactions telles que le survol ou la s\u00e9lection. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<RectangleShapeComponent>(sf::Vector2f(150.0f, 50.0f), sf::Vector2f(100.0f, 200.0f), sf::Color::Blue); Modification des propri\u00e9t\u00e9s : cpp auto *rectangle = entity.getComponent<RectangleShapeComponent>(); if (rectangle) { rectangle->shape.setFillColor(sf::Color::Green); rectangle->shape.setSize(sf::Vector2f(200.0f, 60.0f)); } Interactions Avec HoverComponent : Change la couleur du rectangle lorsque la souris le survole. Avec SelectionComponent : Permet de d\u00e9tecter et d'indiquer si le rectangle est s\u00e9lectionn\u00e9. Avec RenderSystem : Utilis\u00e9 pour dessiner le rectangle \u00e0 l'\u00e9cran. Fonctionnalit\u00e9s principales Apparence dynamique Le composant prend en charge la modification dynamique de l'apparence du rectangle, comme le changement de couleur ou de taille en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements ou des interactions utilisateur. Le composant RectangleShapeComponent offre une repr\u00e9sentation graphique simple et efficace pour des entit\u00e9s interactives, telles que des boutons ou des zones de s\u00e9lection, dans le jeu.","title":"RectangleShapeComponent"},{"location":"components/rectangle_shape/#rectangleshapecomponent","text":"","title":"RectangleShapeComponent"},{"location":"components/rectangle_shape/#introduction","text":"Le composant RectangleShapeComponent est utilis\u00e9 pour repr\u00e9senter des entit\u00e9s sous forme de rectangles graphiques dans le jeu. Il permet de d\u00e9finir l'apparence et la position d'une entit\u00e9 en utilisant un rectangle SFML.","title":"Introduction"},{"location":"components/rectangle_shape/#attributs","text":"shape : Un objet sf::RectangleShape repr\u00e9sentant le rectangle graphique.","title":"Attributs"},{"location":"components/rectangle_shape/#exemple-dattributs-dans-le-fichier-rectangleshapecomponenthpp","text":"#include <SFML/Graphics/RectangleShape.hpp> #include <SFML/System/Vector2.hpp> #include <SFML/Graphics/Color.hpp> class RectangleShapeComponent : public AComponent { public: sf::RectangleShape shape; RectangleShapeComponent(const sf::Vector2f &size, const sf::Vector2f &position, const sf::Color &color) { shape.setSize(size); shape.setPosition(position); shape.setFillColor(color); } };","title":"Exemple d'attributs dans le fichier RectangleShapeComponent.hpp :"},{"location":"components/rectangle_shape/#role-dans-lecs","text":"RectangleShapeComponent est utilis\u00e9 pour : Afficher des entit\u00e9s sous forme de rectangles. D\u00e9finir des propri\u00e9t\u00e9s graphiques comme la taille, la couleur et la position. Fournir une base pour des interactions telles que le survol ou la s\u00e9lection.","title":"R\u00f4le dans l'ECS"},{"location":"components/rectangle_shape/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<RectangleShapeComponent>(sf::Vector2f(150.0f, 50.0f), sf::Vector2f(100.0f, 200.0f), sf::Color::Blue); Modification des propri\u00e9t\u00e9s : cpp auto *rectangle = entity.getComponent<RectangleShapeComponent>(); if (rectangle) { rectangle->shape.setFillColor(sf::Color::Green); rectangle->shape.setSize(sf::Vector2f(200.0f, 60.0f)); }","title":"Exemples d'Utilisation"},{"location":"components/rectangle_shape/#interactions","text":"Avec HoverComponent : Change la couleur du rectangle lorsque la souris le survole. Avec SelectionComponent : Permet de d\u00e9tecter et d'indiquer si le rectangle est s\u00e9lectionn\u00e9. Avec RenderSystem : Utilis\u00e9 pour dessiner le rectangle \u00e0 l'\u00e9cran.","title":"Interactions"},{"location":"components/rectangle_shape/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"components/rectangle_shape/#apparence-dynamique","text":"Le composant prend en charge la modification dynamique de l'apparence du rectangle, comme le changement de couleur ou de taille en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements ou des interactions utilisateur. Le composant RectangleShapeComponent offre une repr\u00e9sentation graphique simple et efficace pour des entit\u00e9s interactives, telles que des boutons ou des zones de s\u00e9lection, dans le jeu.","title":"Apparence dynamique"},{"location":"components/render_component/","text":"RenderComponent Introduction Le composant RenderComponent g\u00e8re les informations n\u00e9cessaires pour afficher une entit\u00e9 \u00e0 l'\u00e9cran. Il contient des donn\u00e9es sur la forme, la couleur et d'autres propri\u00e9t\u00e9s graphiques. Attributs shape : Un objet graphique (par exemple, sf::RectangleShape ou sf::CircleShape ) repr\u00e9sentant l'apparence de l'entit\u00e9. Exemple d'attributs dans le fichier RenderComponent.hpp : #include <SFML/Graphics/RectangleShape.hpp> class RenderComponent : public AComponent { public: sf::RectangleShape shape; RenderComponent(float width, float height, sf::Color color) { shape.setSize(sf::Vector2f(width, height)); shape.setFillColor(color); } }; R\u00f4le dans l'ECS RenderComponent est utilis\u00e9 pour : D\u00e9finir l'apparence visuelle d'une entit\u00e9. Fournir les donn\u00e9es n\u00e9cessaires pour le rendu graphique dans des syst\u00e8mes comme RenderSystem . Permettre des effets visuels tels que le changement de couleur ou de taille en fonction des \u00e9tats du jeu. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<RenderComponent>(50.0f, 50.0f, sf::Color::Red); Mise \u00e0 jour de l'apparence : Dans un syst\u00e8me, on peut modifier les propri\u00e9t\u00e9s du composant : cpp auto *render = entity->getComponent<RenderComponent>(); if (render) { render->shape.setFillColor(sf::Color::Blue); } Rendu dans un syst\u00e8me : Utilis\u00e9 par RenderSystem pour dessiner l'entit\u00e9 : cpp void RenderSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *render = entity->getComponent<RenderComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (render && position) { render->shape.setPosition(position->position); window.draw(render->shape); } } } Interactions Avec PositionComponent : Associe la position de l'entit\u00e9 \u00e0 son rendu graphique. Avec HealthComponent : Permet d'afficher des indicateurs visuels (par exemple, une barre de vie). Avec InputComponent : Peut modifier l'apparence en fonction des actions de l'utilisateur. Le composant RenderComponent est essentiel pour donner vie aux entit\u00e9s du jeu en fournissant les donn\u00e9es n\u00e9cessaires pour les afficher \u00e0 l'\u00e9cran.","title":"RenderComponent"},{"location":"components/render_component/#rendercomponent","text":"","title":"RenderComponent"},{"location":"components/render_component/#introduction","text":"Le composant RenderComponent g\u00e8re les informations n\u00e9cessaires pour afficher une entit\u00e9 \u00e0 l'\u00e9cran. Il contient des donn\u00e9es sur la forme, la couleur et d'autres propri\u00e9t\u00e9s graphiques.","title":"Introduction"},{"location":"components/render_component/#attributs","text":"shape : Un objet graphique (par exemple, sf::RectangleShape ou sf::CircleShape ) repr\u00e9sentant l'apparence de l'entit\u00e9.","title":"Attributs"},{"location":"components/render_component/#exemple-dattributs-dans-le-fichier-rendercomponenthpp","text":"#include <SFML/Graphics/RectangleShape.hpp> class RenderComponent : public AComponent { public: sf::RectangleShape shape; RenderComponent(float width, float height, sf::Color color) { shape.setSize(sf::Vector2f(width, height)); shape.setFillColor(color); } };","title":"Exemple d'attributs dans le fichier RenderComponent.hpp :"},{"location":"components/render_component/#role-dans-lecs","text":"RenderComponent est utilis\u00e9 pour : D\u00e9finir l'apparence visuelle d'une entit\u00e9. Fournir les donn\u00e9es n\u00e9cessaires pour le rendu graphique dans des syst\u00e8mes comme RenderSystem . Permettre des effets visuels tels que le changement de couleur ou de taille en fonction des \u00e9tats du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"components/render_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<RenderComponent>(50.0f, 50.0f, sf::Color::Red); Mise \u00e0 jour de l'apparence : Dans un syst\u00e8me, on peut modifier les propri\u00e9t\u00e9s du composant : cpp auto *render = entity->getComponent<RenderComponent>(); if (render) { render->shape.setFillColor(sf::Color::Blue); } Rendu dans un syst\u00e8me : Utilis\u00e9 par RenderSystem pour dessiner l'entit\u00e9 : cpp void RenderSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *render = entity->getComponent<RenderComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (render && position) { render->shape.setPosition(position->position); window.draw(render->shape); } } }","title":"Exemples d'Utilisation"},{"location":"components/render_component/#interactions","text":"Avec PositionComponent : Associe la position de l'entit\u00e9 \u00e0 son rendu graphique. Avec HealthComponent : Permet d'afficher des indicateurs visuels (par exemple, une barre de vie). Avec InputComponent : Peut modifier l'apparence en fonction des actions de l'utilisateur. Le composant RenderComponent est essentiel pour donner vie aux entit\u00e9s du jeu en fournissant les donn\u00e9es n\u00e9cessaires pour les afficher \u00e0 l'\u00e9cran.","title":"Interactions"},{"location":"components/selection_component/","text":"SelectionComponent Introduction Le composant SelectionComponent est utilis\u00e9 pour indiquer si une entit\u00e9 est s\u00e9lectionn\u00e9e. Il est particuli\u00e8rement utile pour des interactions utilisateur, comme la s\u00e9lection de boutons, d'objets ou de zones dans le jeu. Attributs isSelected : Un bool\u00e9en indiquant si l'entit\u00e9 est actuellement s\u00e9lectionn\u00e9e. Exemple d'attributs dans le fichier SelectionComponent.hpp : class SelectionComponent : public AComponent { public: bool isSelected; SelectionComponent() : isSelected(false) {} }; R\u00f4le dans l'ECS SelectionComponent est utilis\u00e9 pour : Identifier les entit\u00e9s qui sont activement s\u00e9lectionn\u00e9es par l'utilisateur. Permettre aux syst\u00e8mes de r\u00e9agir \u00e0 l'\u00e9tat de s\u00e9lection d'une entit\u00e9. Indiquer visuellement ou logiquement les entit\u00e9s choisies. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<SelectionComponent>(); V\u00e9rification de la s\u00e9lection : cpp auto *selection = entity.getComponent<SelectionComponent>(); if (selection && selection->isSelected) { std::cout << \"Entit\u00e9 s\u00e9lectionn\u00e9e !\" << std::endl; } Mise \u00e0 jour de l'\u00e9tat de s\u00e9lection : cpp auto *selection = entity.getComponent<SelectionComponent>(); if (selection) { selection->isSelected = true; } Interactions Avec SelectionSystem : Change l'\u00e9tat isSelected en fonction des interactions utilisateur. Avec RectangleShapeComponent et SpriteComponent : Peut \u00eatre utilis\u00e9 pour afficher visuellement l'\u00e9tat de s\u00e9lection (par exemple, en changeant la couleur ou la bordure). Fonctionnalit\u00e9s principales D\u00e9tection de la s\u00e9lection Le composant fonctionne avec des syst\u00e8mes comme SelectionSystem pour d\u00e9tecter les clics ou autres interactions utilisateur qui d\u00e9terminent si une entit\u00e9 est s\u00e9lectionn\u00e9e ou non. Le composant SelectionComponent est une brique essentielle pour impl\u00e9menter des interactions utilisateur intuitives, telles que la s\u00e9lection d'objets ou de zones interactives.","title":"SelectionComponent"},{"location":"components/selection_component/#selectioncomponent","text":"","title":"SelectionComponent"},{"location":"components/selection_component/#introduction","text":"Le composant SelectionComponent est utilis\u00e9 pour indiquer si une entit\u00e9 est s\u00e9lectionn\u00e9e. Il est particuli\u00e8rement utile pour des interactions utilisateur, comme la s\u00e9lection de boutons, d'objets ou de zones dans le jeu.","title":"Introduction"},{"location":"components/selection_component/#attributs","text":"isSelected : Un bool\u00e9en indiquant si l'entit\u00e9 est actuellement s\u00e9lectionn\u00e9e.","title":"Attributs"},{"location":"components/selection_component/#exemple-dattributs-dans-le-fichier-selectioncomponenthpp","text":"class SelectionComponent : public AComponent { public: bool isSelected; SelectionComponent() : isSelected(false) {} };","title":"Exemple d'attributs dans le fichier SelectionComponent.hpp :"},{"location":"components/selection_component/#role-dans-lecs","text":"SelectionComponent est utilis\u00e9 pour : Identifier les entit\u00e9s qui sont activement s\u00e9lectionn\u00e9es par l'utilisateur. Permettre aux syst\u00e8mes de r\u00e9agir \u00e0 l'\u00e9tat de s\u00e9lection d'une entit\u00e9. Indiquer visuellement ou logiquement les entit\u00e9s choisies.","title":"R\u00f4le dans l'ECS"},{"location":"components/selection_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<SelectionComponent>(); V\u00e9rification de la s\u00e9lection : cpp auto *selection = entity.getComponent<SelectionComponent>(); if (selection && selection->isSelected) { std::cout << \"Entit\u00e9 s\u00e9lectionn\u00e9e !\" << std::endl; } Mise \u00e0 jour de l'\u00e9tat de s\u00e9lection : cpp auto *selection = entity.getComponent<SelectionComponent>(); if (selection) { selection->isSelected = true; }","title":"Exemples d'Utilisation"},{"location":"components/selection_component/#interactions","text":"Avec SelectionSystem : Change l'\u00e9tat isSelected en fonction des interactions utilisateur. Avec RectangleShapeComponent et SpriteComponent : Peut \u00eatre utilis\u00e9 pour afficher visuellement l'\u00e9tat de s\u00e9lection (par exemple, en changeant la couleur ou la bordure).","title":"Interactions"},{"location":"components/selection_component/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"components/selection_component/#detection-de-la-selection","text":"Le composant fonctionne avec des syst\u00e8mes comme SelectionSystem pour d\u00e9tecter les clics ou autres interactions utilisateur qui d\u00e9terminent si une entit\u00e9 est s\u00e9lectionn\u00e9e ou non. Le composant SelectionComponent est une brique essentielle pour impl\u00e9menter des interactions utilisateur intuitives, telles que la s\u00e9lection d'objets ou de zones interactives.","title":"D\u00e9tection de la s\u00e9lection"},{"location":"components/sound_component/","text":"SoundComponent Introduction Le composant SoundComponent est utilis\u00e9 pour g\u00e9rer les effets sonores associ\u00e9s \u00e0 une entit\u00e9. Il permet de jouer des sons, de les configurer et de contr\u00f4ler leur comportement, comme le volume et la r\u00e9p\u00e9tition. Attributs sound : Un objet sf::Sound pour jouer le son. buffer : Un objet sf::SoundBuffer qui contient les donn\u00e9es audio. maxTimesPlayed : Nombre maximum de fois que le son peut \u00eatre jou\u00e9 (-1 pour une boucle infinie). timesPlayed : Nombre de fois que le son a \u00e9t\u00e9 jou\u00e9. Exemple d'attributs dans le fichier SoundComponent.hpp : #include <SFML/Audio/Sound.hpp> #include <SFML/Audio/SoundBuffer.hpp> class SoundComponent : public AComponent { public: sf::Sound sound; sf::SoundBuffer buffer; int maxTimesPlayed; int timesPlayed; SoundComponent(const std::string &soundPath, int maxTimesPlayed) : maxTimesPlayed(maxTimesPlayed), timesPlayed(0) { if (!buffer.loadFromFile(soundPath)) { throw std::runtime_error(\"Failed to load sound: \" + soundPath); } sound.setBuffer(buffer); } }; R\u00f4le dans l'ECS SoundComponent est utilis\u00e9 pour : Ajouter des effets sonores aux entit\u00e9s. G\u00e9rer le comportement des sons, comme leur volume et leur r\u00e9p\u00e9tition. Synchroniser les sons avec des \u00e9v\u00e9nements du jeu. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &explosion = entityManager.createEntity(); explosion.addComponent<SoundComponent>(\"assets/explosion.wav\", 1); Configuration du volume : cpp auto *sound = entity.getComponent<SoundComponent>(); if (sound) { sound->sound.setVolume(50.0f); } Lecture du son : cpp auto *sound = entity.getComponent<SoundComponent>(); if (sound) { sound->sound.play(); } Interactions Avec SoundSystem : Le syst\u00e8me contr\u00f4le la lecture des sons en fonction des composants attach\u00e9s aux entit\u00e9s. Avec EventHandlerComponent : Peut d\u00e9clencher des sons en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements sp\u00e9cifiques. Fonctionnalit\u00e9s principales Gestion des sons en boucle Le composant prend en charge les sons jou\u00e9s en boucle infinie ou un nombre limit\u00e9 de fois. Il utilise maxTimesPlayed pour d\u00e9finir la dur\u00e9e de lecture. Le composant SoundComponent enrichit l'exp\u00e9rience utilisateur en ajoutant une couche audio dynamique et immersive aux interactions du jeu.","title":"SoundComponent"},{"location":"components/sound_component/#soundcomponent","text":"","title":"SoundComponent"},{"location":"components/sound_component/#introduction","text":"Le composant SoundComponent est utilis\u00e9 pour g\u00e9rer les effets sonores associ\u00e9s \u00e0 une entit\u00e9. Il permet de jouer des sons, de les configurer et de contr\u00f4ler leur comportement, comme le volume et la r\u00e9p\u00e9tition.","title":"Introduction"},{"location":"components/sound_component/#attributs","text":"sound : Un objet sf::Sound pour jouer le son. buffer : Un objet sf::SoundBuffer qui contient les donn\u00e9es audio. maxTimesPlayed : Nombre maximum de fois que le son peut \u00eatre jou\u00e9 (-1 pour une boucle infinie). timesPlayed : Nombre de fois que le son a \u00e9t\u00e9 jou\u00e9.","title":"Attributs"},{"location":"components/sound_component/#exemple-dattributs-dans-le-fichier-soundcomponenthpp","text":"#include <SFML/Audio/Sound.hpp> #include <SFML/Audio/SoundBuffer.hpp> class SoundComponent : public AComponent { public: sf::Sound sound; sf::SoundBuffer buffer; int maxTimesPlayed; int timesPlayed; SoundComponent(const std::string &soundPath, int maxTimesPlayed) : maxTimesPlayed(maxTimesPlayed), timesPlayed(0) { if (!buffer.loadFromFile(soundPath)) { throw std::runtime_error(\"Failed to load sound: \" + soundPath); } sound.setBuffer(buffer); } };","title":"Exemple d'attributs dans le fichier SoundComponent.hpp :"},{"location":"components/sound_component/#role-dans-lecs","text":"SoundComponent est utilis\u00e9 pour : Ajouter des effets sonores aux entit\u00e9s. G\u00e9rer le comportement des sons, comme leur volume et leur r\u00e9p\u00e9tition. Synchroniser les sons avec des \u00e9v\u00e9nements du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"components/sound_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &explosion = entityManager.createEntity(); explosion.addComponent<SoundComponent>(\"assets/explosion.wav\", 1); Configuration du volume : cpp auto *sound = entity.getComponent<SoundComponent>(); if (sound) { sound->sound.setVolume(50.0f); } Lecture du son : cpp auto *sound = entity.getComponent<SoundComponent>(); if (sound) { sound->sound.play(); }","title":"Exemples d'Utilisation"},{"location":"components/sound_component/#interactions","text":"Avec SoundSystem : Le syst\u00e8me contr\u00f4le la lecture des sons en fonction des composants attach\u00e9s aux entit\u00e9s. Avec EventHandlerComponent : Peut d\u00e9clencher des sons en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements sp\u00e9cifiques.","title":"Interactions"},{"location":"components/sound_component/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"components/sound_component/#gestion-des-sons-en-boucle","text":"Le composant prend en charge les sons jou\u00e9s en boucle infinie ou un nombre limit\u00e9 de fois. Il utilise maxTimesPlayed pour d\u00e9finir la dur\u00e9e de lecture. Le composant SoundComponent enrichit l'exp\u00e9rience utilisateur en ajoutant une couche audio dynamique et immersive aux interactions du jeu.","title":"Gestion des sons en boucle"},{"location":"components/sprite_component/","text":"SpriteComponent Introduction Le composant SpriteComponent est con\u00e7u pour g\u00e9rer les sprites graphiques associ\u00e9s \u00e0 une entit\u00e9. Il permet d'afficher des textures complexes, telles que des personnages ou des objets, en utilisant des images. Attributs sprite : Un objet sf::Sprite qui contient la texture et les informations associ\u00e9es pour le rendu. texture : Un objet sf::Texture qui stocke l'image utilis\u00e9e par le sprite. Exemple d'attributs dans le fichier SpriteComponent.hpp : #include <SFML/Graphics/Sprite.hpp> #include <SFML/Graphics/Texture.hpp> class SpriteComponent : public AComponent { public: sf::Sprite sprite; sf::Texture texture; SpriteComponent(const std::string &texturePath) { if (!texture.loadFromFile(texturePath)) { throw std::runtime_error(\"Failed to load texture: \" + texturePath); } sprite.setTexture(texture); } }; R\u00f4le dans l'ECS SpriteComponent est utilis\u00e9 pour : Afficher des textures personnalis\u00e9es sur les entit\u00e9s. G\u00e9rer les animations ou les changements d'apparence en modifiant les propri\u00e9t\u00e9s du sprite. Compl\u00e9ter RenderComponent pour des affichages graphiques plus d\u00e9taill\u00e9s. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<SpriteComponent>(\"assets/player.png\"); Modification de la texture : cpp auto *sprite = entity->getComponent<SpriteComponent>(); if (sprite) { if (!sprite->texture.loadFromFile(\"assets/enemy.png\")) { throw std::runtime_error(\"Failed to load texture\"); } sprite->sprite.setTexture(sprite->texture); } Rendu dans un syst\u00e8me : Utilis\u00e9 par RenderSystem pour dessiner le sprite : cpp void RenderSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *sprite = entity->getComponent<SpriteComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (sprite && position) { sprite->sprite.setPosition(position->position); window.draw(sprite->sprite); } } } Interactions Avec PositionComponent : Positionne le sprite \u00e0 l'endroit appropri\u00e9 sur l'\u00e9cran. Avec AnimationSystem : Permet de g\u00e9rer les animations en modifiant les textures ou les propri\u00e9t\u00e9s du sprite. Le composant SpriteComponent est id\u00e9al pour des entit\u00e9s n\u00e9cessitant des visuels complexes, offrant une flexibilit\u00e9 pour le rendu d'images dans le jeu.","title":"SpriteComponent"},{"location":"components/sprite_component/#spritecomponent","text":"","title":"SpriteComponent"},{"location":"components/sprite_component/#introduction","text":"Le composant SpriteComponent est con\u00e7u pour g\u00e9rer les sprites graphiques associ\u00e9s \u00e0 une entit\u00e9. Il permet d'afficher des textures complexes, telles que des personnages ou des objets, en utilisant des images.","title":"Introduction"},{"location":"components/sprite_component/#attributs","text":"sprite : Un objet sf::Sprite qui contient la texture et les informations associ\u00e9es pour le rendu. texture : Un objet sf::Texture qui stocke l'image utilis\u00e9e par le sprite.","title":"Attributs"},{"location":"components/sprite_component/#exemple-dattributs-dans-le-fichier-spritecomponenthpp","text":"#include <SFML/Graphics/Sprite.hpp> #include <SFML/Graphics/Texture.hpp> class SpriteComponent : public AComponent { public: sf::Sprite sprite; sf::Texture texture; SpriteComponent(const std::string &texturePath) { if (!texture.loadFromFile(texturePath)) { throw std::runtime_error(\"Failed to load texture: \" + texturePath); } sprite.setTexture(texture); } };","title":"Exemple d'attributs dans le fichier SpriteComponent.hpp :"},{"location":"components/sprite_component/#role-dans-lecs","text":"SpriteComponent est utilis\u00e9 pour : Afficher des textures personnalis\u00e9es sur les entit\u00e9s. G\u00e9rer les animations ou les changements d'apparence en modifiant les propri\u00e9t\u00e9s du sprite. Compl\u00e9ter RenderComponent pour des affichages graphiques plus d\u00e9taill\u00e9s.","title":"R\u00f4le dans l'ECS"},{"location":"components/sprite_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<SpriteComponent>(\"assets/player.png\"); Modification de la texture : cpp auto *sprite = entity->getComponent<SpriteComponent>(); if (sprite) { if (!sprite->texture.loadFromFile(\"assets/enemy.png\")) { throw std::runtime_error(\"Failed to load texture\"); } sprite->sprite.setTexture(sprite->texture); } Rendu dans un syst\u00e8me : Utilis\u00e9 par RenderSystem pour dessiner le sprite : cpp void RenderSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *sprite = entity->getComponent<SpriteComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (sprite && position) { sprite->sprite.setPosition(position->position); window.draw(sprite->sprite); } } }","title":"Exemples d'Utilisation"},{"location":"components/sprite_component/#interactions","text":"Avec PositionComponent : Positionne le sprite \u00e0 l'endroit appropri\u00e9 sur l'\u00e9cran. Avec AnimationSystem : Permet de g\u00e9rer les animations en modifiant les textures ou les propri\u00e9t\u00e9s du sprite. Le composant SpriteComponent est id\u00e9al pour des entit\u00e9s n\u00e9cessitant des visuels complexes, offrant une flexibilit\u00e9 pour le rendu d'images dans le jeu.","title":"Interactions"},{"location":"components/text_component/","text":"TextComponent Introduction Le composant TextComponent est utilis\u00e9 pour afficher du texte associ\u00e9 \u00e0 une entit\u00e9. Il permet de configurer et de styliser le texte, ainsi que de le positionner dans le monde du jeu. Attributs data : Un objet sf::Text repr\u00e9sentant le texte affich\u00e9. font : Un objet sf::Font utilis\u00e9 pour styler le texte. Exemple d'attributs dans le fichier TextComponent.hpp : #include <SFML/Graphics/Text.hpp> #include <SFML/Graphics/Font.hpp> class TextComponent : public AComponent { public: sf::Text data; sf::Font font; TextComponent(const std::string &text, const sf::Font &font, const sf::Vector2f &position, const sf::Color &color) : font(font) { data.setFont(this->font); data.setString(text); data.setPosition(position); data.setFillColor(color); } }; R\u00f4le dans l'ECS TextComponent est utilis\u00e9 pour : Afficher du texte contextuel, tel que des noms d'utilisateur ou des informations de jeu. G\u00e9rer les propri\u00e9t\u00e9s du texte, comme la taille de la police, la couleur et le style. Synchroniser les textes avec les \u00e9tats des entit\u00e9s. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &playerLabel = entityManager.createEntity(); playerLabel.addComponent<TextComponent>(\"Player1\", font, sf::Vector2f(100.0f, 200.0f), sf::Color::White); Modification du texte : cpp auto *text = entity.getComponent<TextComponent>(); if (text) { text->data.setString(\"Nouveau Texte\"); } Changement de couleur : cpp auto *text = entity.getComponent<TextComponent>(); if (text) { text->data.setFillColor(sf::Color::Red); } Interactions Avec RenderSystem : Le syst\u00e8me dessine les textes des entit\u00e9s \u00e0 l'\u00e9cran. Avec EventHandlerComponent : Permet de mettre \u00e0 jour dynamiquement le texte en fonction des \u00e9v\u00e9nements du jeu. Fonctionnalit\u00e9s principales Affichage de texte dynamique Le composant permet de mettre \u00e0 jour le contenu textuel en temps r\u00e9el, ce qui est utile pour afficher des informations contextuelles ou des changements d'\u00e9tat dans le jeu. Le composant TextComponent est un outil puissant pour afficher des informations textuelles dynamiques, ajoutant une couche de clart\u00e9 et d'immersion au jeu.","title":"TextComponent"},{"location":"components/text_component/#textcomponent","text":"","title":"TextComponent"},{"location":"components/text_component/#introduction","text":"Le composant TextComponent est utilis\u00e9 pour afficher du texte associ\u00e9 \u00e0 une entit\u00e9. Il permet de configurer et de styliser le texte, ainsi que de le positionner dans le monde du jeu.","title":"Introduction"},{"location":"components/text_component/#attributs","text":"data : Un objet sf::Text repr\u00e9sentant le texte affich\u00e9. font : Un objet sf::Font utilis\u00e9 pour styler le texte.","title":"Attributs"},{"location":"components/text_component/#exemple-dattributs-dans-le-fichier-textcomponenthpp","text":"#include <SFML/Graphics/Text.hpp> #include <SFML/Graphics/Font.hpp> class TextComponent : public AComponent { public: sf::Text data; sf::Font font; TextComponent(const std::string &text, const sf::Font &font, const sf::Vector2f &position, const sf::Color &color) : font(font) { data.setFont(this->font); data.setString(text); data.setPosition(position); data.setFillColor(color); } };","title":"Exemple d'attributs dans le fichier TextComponent.hpp :"},{"location":"components/text_component/#role-dans-lecs","text":"TextComponent est utilis\u00e9 pour : Afficher du texte contextuel, tel que des noms d'utilisateur ou des informations de jeu. G\u00e9rer les propri\u00e9t\u00e9s du texte, comme la taille de la police, la couleur et le style. Synchroniser les textes avec les \u00e9tats des entit\u00e9s.","title":"R\u00f4le dans l'ECS"},{"location":"components/text_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &playerLabel = entityManager.createEntity(); playerLabel.addComponent<TextComponent>(\"Player1\", font, sf::Vector2f(100.0f, 200.0f), sf::Color::White); Modification du texte : cpp auto *text = entity.getComponent<TextComponent>(); if (text) { text->data.setString(\"Nouveau Texte\"); } Changement de couleur : cpp auto *text = entity.getComponent<TextComponent>(); if (text) { text->data.setFillColor(sf::Color::Red); }","title":"Exemples d'Utilisation"},{"location":"components/text_component/#interactions","text":"Avec RenderSystem : Le syst\u00e8me dessine les textes des entit\u00e9s \u00e0 l'\u00e9cran. Avec EventHandlerComponent : Permet de mettre \u00e0 jour dynamiquement le texte en fonction des \u00e9v\u00e9nements du jeu.","title":"Interactions"},{"location":"components/text_component/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"components/text_component/#affichage-de-texte-dynamique","text":"Le composant permet de mettre \u00e0 jour le contenu textuel en temps r\u00e9el, ce qui est utile pour afficher des informations contextuelles ou des changements d'\u00e9tat dans le jeu. Le composant TextComponent est un outil puissant pour afficher des informations textuelles dynamiques, ajoutant une couche de clart\u00e9 et d'immersion au jeu.","title":"Affichage de texte dynamique"},{"location":"components/username_component/","text":"UsernameComponent Introduction Le composant UsernameComponent est utilis\u00e9 pour associer un identifiant utilisateur unique \u00e0 une entit\u00e9. Ce composant est essentiel dans un environnement multijoueur pour diff\u00e9rencier les joueurs. Attributs username : Une cha\u00eene de caract\u00e8res repr\u00e9sentant l'identifiant unique d'un joueur. Exemple d'attributs dans le fichier UsernameComponent.hpp : class UsernameComponent : public AComponent { public: std::string username; UsernameComponent(const std::string &username) : username(username) {} }; R\u00f4le dans l'ECS UsernameComponent est utilis\u00e9 pour : Identifier de mani\u00e8re unique les joueurs dans le syst\u00e8me. Faciliter les interactions entre joueurs et la gestion des scores, des statistiques ou d'autres informations sp\u00e9cifiques. Synchroniser les informations utilisateur entre les clients et le serveur dans un jeu en r\u00e9seau. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<UsernameComponent>(\"Player1\"); R\u00e9cup\u00e9ration du nom d'utilisateur : cpp auto *username = entity->getComponent<UsernameComponent>(); if (username) { std::cout << \"Nom d'utilisateur : \" << username->username << std::endl; } Utilisation dans un syst\u00e8me : Dans un syst\u00e8me comme MessageSystem , ce composant peut \u00eatre utilis\u00e9 pour associer les actions ou \u00e9v\u00e9nements \u00e0 un joueur sp\u00e9cifique : cpp auto *username = entity->getComponent<UsernameComponent>(); if (username) { std::cout << \"Synchronisation des donn\u00e9es pour : \" << username->username << std::endl; } Interactions Avec NetworkComponent : Associe le nom d'utilisateur \u00e0 des donn\u00e9es r\u00e9seau sp\u00e9cifiques pour la synchronisation. Avec RenderSystem : Affiche le nom d'utilisateur au-dessus de l'entit\u00e9 correspondante. Le composant UsernameComponent est essentiel pour identifier les joueurs dans un environnement multijoueur et g\u00e9rer les interactions sp\u00e9cifiques \u00e0 chaque utilisateur.","title":"UsernameComponent"},{"location":"components/username_component/#usernamecomponent","text":"","title":"UsernameComponent"},{"location":"components/username_component/#introduction","text":"Le composant UsernameComponent est utilis\u00e9 pour associer un identifiant utilisateur unique \u00e0 une entit\u00e9. Ce composant est essentiel dans un environnement multijoueur pour diff\u00e9rencier les joueurs.","title":"Introduction"},{"location":"components/username_component/#attributs","text":"username : Une cha\u00eene de caract\u00e8res repr\u00e9sentant l'identifiant unique d'un joueur.","title":"Attributs"},{"location":"components/username_component/#exemple-dattributs-dans-le-fichier-usernamecomponenthpp","text":"class UsernameComponent : public AComponent { public: std::string username; UsernameComponent(const std::string &username) : username(username) {} };","title":"Exemple d'attributs dans le fichier UsernameComponent.hpp :"},{"location":"components/username_component/#role-dans-lecs","text":"UsernameComponent est utilis\u00e9 pour : Identifier de mani\u00e8re unique les joueurs dans le syst\u00e8me. Faciliter les interactions entre joueurs et la gestion des scores, des statistiques ou d'autres informations sp\u00e9cifiques. Synchroniser les informations utilisateur entre les clients et le serveur dans un jeu en r\u00e9seau.","title":"R\u00f4le dans l'ECS"},{"location":"components/username_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<UsernameComponent>(\"Player1\"); R\u00e9cup\u00e9ration du nom d'utilisateur : cpp auto *username = entity->getComponent<UsernameComponent>(); if (username) { std::cout << \"Nom d'utilisateur : \" << username->username << std::endl; } Utilisation dans un syst\u00e8me : Dans un syst\u00e8me comme MessageSystem , ce composant peut \u00eatre utilis\u00e9 pour associer les actions ou \u00e9v\u00e9nements \u00e0 un joueur sp\u00e9cifique : cpp auto *username = entity->getComponent<UsernameComponent>(); if (username) { std::cout << \"Synchronisation des donn\u00e9es pour : \" << username->username << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/username_component/#interactions","text":"Avec NetworkComponent : Associe le nom d'utilisateur \u00e0 des donn\u00e9es r\u00e9seau sp\u00e9cifiques pour la synchronisation. Avec RenderSystem : Affiche le nom d'utilisateur au-dessus de l'entit\u00e9 correspondante. Le composant UsernameComponent est essentiel pour identifier les joueurs dans un environnement multijoueur et g\u00e9rer les interactions sp\u00e9cifiques \u00e0 chaque utilisateur.","title":"Interactions"},{"location":"components/velocity_component/","text":"VelocityComponent Introduction Le composant VelocityComponent est utilis\u00e9 pour repr\u00e9senter la vitesse et la direction d'une entit\u00e9 dans le jeu. Il permet de g\u00e9rer les d\u00e9placements en combinant les informations de position et de vitesse. Attributs velocity : Un vecteur 2D (souvent sf::Vector2f ) repr\u00e9sentant la vitesse sur les axes X et Y. Exemple d'attributs dans le fichier VelocityComponent.hpp : #include <SFML/System/Vector2.hpp> class VelocityComponent : public AComponent { public: sf::Vector2f velocity; VelocityComponent(float x, float y) : velocity(x, y) {} }; R\u00f4le dans l'ECS VelocityComponent est utilis\u00e9 pour : D\u00e9finir la vitesse et la direction des entit\u00e9s en mouvement. Permettre aux syst\u00e8mes comme MovementSystem d'effectuer des mises \u00e0 jour pr\u00e9cises de la position des entit\u00e9s. Impl\u00e9menter des m\u00e9caniques de jeu telles que des projectiles, des ennemis en mouvement ou des v\u00e9hicules. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<VelocityComponent>(100.0f, 0.0f); Mise \u00e0 jour de la vitesse : cpp auto *velocity = entity->getComponent<VelocityComponent>(); if (velocity) { velocity->velocity.x += 10.0f; velocity->velocity.y -= 5.0f; } Utilisation dans un syst\u00e8me : Dans un syst\u00e8me comme MovementSystem , la vitesse est utilis\u00e9e pour mettre \u00e0 jour la position : cpp void MovementSystem::update(EntityManager &entityManager, float deltaTime) { for (auto &entity : entityManager.entities) { auto *velocity = entity->getComponent<VelocityComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (velocity && position) { position->position.x += velocity->velocity.x * deltaTime; position->position.y += velocity->velocity.y * deltaTime; } } } Interactions Avec PositionComponent : Combine les informations de vitesse pour mettre \u00e0 jour la position des entit\u00e9s. Avec InputComponent : Modifie la direction et la vitesse en fonction des commandes utilisateur. Avec CollisionSystem : Peut inverser ou ajuster la vitesse lors de collisions. Le composant VelocityComponent est essentiel pour impl\u00e9menter des m\u00e9caniques de mouvement r\u00e9alistes et dynamiques dans le jeu.","title":"VelocityComponent"},{"location":"components/velocity_component/#velocitycomponent","text":"","title":"VelocityComponent"},{"location":"components/velocity_component/#introduction","text":"Le composant VelocityComponent est utilis\u00e9 pour repr\u00e9senter la vitesse et la direction d'une entit\u00e9 dans le jeu. Il permet de g\u00e9rer les d\u00e9placements en combinant les informations de position et de vitesse.","title":"Introduction"},{"location":"components/velocity_component/#attributs","text":"velocity : Un vecteur 2D (souvent sf::Vector2f ) repr\u00e9sentant la vitesse sur les axes X et Y.","title":"Attributs"},{"location":"components/velocity_component/#exemple-dattributs-dans-le-fichier-velocitycomponenthpp","text":"#include <SFML/System/Vector2.hpp> class VelocityComponent : public AComponent { public: sf::Vector2f velocity; VelocityComponent(float x, float y) : velocity(x, y) {} };","title":"Exemple d'attributs dans le fichier VelocityComponent.hpp :"},{"location":"components/velocity_component/#role-dans-lecs","text":"VelocityComponent est utilis\u00e9 pour : D\u00e9finir la vitesse et la direction des entit\u00e9s en mouvement. Permettre aux syst\u00e8mes comme MovementSystem d'effectuer des mises \u00e0 jour pr\u00e9cises de la position des entit\u00e9s. Impl\u00e9menter des m\u00e9caniques de jeu telles que des projectiles, des ennemis en mouvement ou des v\u00e9hicules.","title":"R\u00f4le dans l'ECS"},{"location":"components/velocity_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &entity = entityManager.createEntity(); entity.addComponent<VelocityComponent>(100.0f, 0.0f); Mise \u00e0 jour de la vitesse : cpp auto *velocity = entity->getComponent<VelocityComponent>(); if (velocity) { velocity->velocity.x += 10.0f; velocity->velocity.y -= 5.0f; } Utilisation dans un syst\u00e8me : Dans un syst\u00e8me comme MovementSystem , la vitesse est utilis\u00e9e pour mettre \u00e0 jour la position : cpp void MovementSystem::update(EntityManager &entityManager, float deltaTime) { for (auto &entity : entityManager.entities) { auto *velocity = entity->getComponent<VelocityComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (velocity && position) { position->position.x += velocity->velocity.x * deltaTime; position->position.y += velocity->velocity.y * deltaTime; } } }","title":"Exemples d'Utilisation"},{"location":"components/velocity_component/#interactions","text":"Avec PositionComponent : Combine les informations de vitesse pour mettre \u00e0 jour la position des entit\u00e9s. Avec InputComponent : Modifie la direction et la vitesse en fonction des commandes utilisateur. Avec CollisionSystem : Peut inverser ou ajuster la vitesse lors de collisions. Le composant VelocityComponent est essentiel pour impl\u00e9menter des m\u00e9caniques de mouvement r\u00e9alistes et dynamiques dans le jeu.","title":"Interactions"},{"location":"entities/ally_entity/","text":"AllyEntity Introduction AllyEntity repr\u00e9sente une entit\u00e9 alli\u00e9e dans le jeu. Ce type d'entit\u00e9 est con\u00e7u pour interagir avec le joueur et peut afficher des informations telles que le nom d'utilisateur associ\u00e9. R\u00f4le dans l'ECS AllyEntity est utilis\u00e9 pour : Repr\u00e9senter les alli\u00e9s du joueur avec des propri\u00e9t\u00e9s visuelles et textuelles. Int\u00e9grer des composants pour la position, le rendu et l'identit\u00e9. Attributs Les entit\u00e9s alli\u00e9es sont cr\u00e9\u00e9es avec les composants suivants : PositionComponent : D\u00e9finit la position de l'alli\u00e9. SpriteComponent : Affiche un sprite graphique pour repr\u00e9senter visuellement l'alli\u00e9. UsernameComponent : Associe un nom d'utilisateur \u00e0 l'entit\u00e9. TextComponent : Affiche le nom d'utilisateur \u00e0 c\u00f4t\u00e9 ou au-dessus de l'entit\u00e9. Exemple de cr\u00e9ation Code extrait de AllyEntity.cpp : Entity &AllyEntity::createAllyEntity( EntityManager &entityManager, float x, float y, const std::string &username, const sf::Font &font) { Entity &ally = entityManager.createEntity(); ally.addComponent<PositionComponent>(x, y); ally.addComponent<SpriteComponent>(\"assets/Ally64x64.png\", sf::Vector2f(1, 1)); ally.addComponent<usernameComponent>(username); auto &text = ally.addComponent<TextComponent>(username, font, sf::Vector2f(x, y), sf::Color::White); text.data.setCharacterSize(24); return ally; } Interactions Avec RenderSystem : Affiche l'entit\u00e9 alli\u00e9e et son texte associ\u00e9 \u00e0 l'\u00e9cran. Avec PositionComponent : Met \u00e0 jour la position de l'alli\u00e9. Avec UsernameComponent : Identifie l'alli\u00e9 avec un nom unique. Exemples d'Utilisation Cr\u00e9ation d'un alli\u00e9 : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); AllyEntity::createAllyEntity(entityManager, 100.0f, 200.0f, \"Ally1\", font); Mise \u00e0 jour de la position : cpp auto *position = allyEntity.getComponent<PositionComponent>(); if (position) { position->position.x += 10.0f; } AllyEntity fournit une base solide pour g\u00e9rer les entit\u00e9s alli\u00e9es dans le jeu, offrant des fonctionnalit\u00e9s visuelles et des interactions conviviales pour le joueur.","title":"AllyEntity"},{"location":"entities/ally_entity/#allyentity","text":"","title":"AllyEntity"},{"location":"entities/ally_entity/#introduction","text":"AllyEntity repr\u00e9sente une entit\u00e9 alli\u00e9e dans le jeu. Ce type d'entit\u00e9 est con\u00e7u pour interagir avec le joueur et peut afficher des informations telles que le nom d'utilisateur associ\u00e9.","title":"Introduction"},{"location":"entities/ally_entity/#role-dans-lecs","text":"AllyEntity est utilis\u00e9 pour : Repr\u00e9senter les alli\u00e9s du joueur avec des propri\u00e9t\u00e9s visuelles et textuelles. Int\u00e9grer des composants pour la position, le rendu et l'identit\u00e9.","title":"R\u00f4le dans l'ECS"},{"location":"entities/ally_entity/#attributs","text":"Les entit\u00e9s alli\u00e9es sont cr\u00e9\u00e9es avec les composants suivants : PositionComponent : D\u00e9finit la position de l'alli\u00e9. SpriteComponent : Affiche un sprite graphique pour repr\u00e9senter visuellement l'alli\u00e9. UsernameComponent : Associe un nom d'utilisateur \u00e0 l'entit\u00e9. TextComponent : Affiche le nom d'utilisateur \u00e0 c\u00f4t\u00e9 ou au-dessus de l'entit\u00e9.","title":"Attributs"},{"location":"entities/ally_entity/#exemple-de-creation","text":"","title":"Exemple de cr\u00e9ation"},{"location":"entities/ally_entity/#code-extrait-de-allyentitycpp","text":"Entity &AllyEntity::createAllyEntity( EntityManager &entityManager, float x, float y, const std::string &username, const sf::Font &font) { Entity &ally = entityManager.createEntity(); ally.addComponent<PositionComponent>(x, y); ally.addComponent<SpriteComponent>(\"assets/Ally64x64.png\", sf::Vector2f(1, 1)); ally.addComponent<usernameComponent>(username); auto &text = ally.addComponent<TextComponent>(username, font, sf::Vector2f(x, y), sf::Color::White); text.data.setCharacterSize(24); return ally; }","title":"Code extrait de AllyEntity.cpp :"},{"location":"entities/ally_entity/#interactions","text":"Avec RenderSystem : Affiche l'entit\u00e9 alli\u00e9e et son texte associ\u00e9 \u00e0 l'\u00e9cran. Avec PositionComponent : Met \u00e0 jour la position de l'alli\u00e9. Avec UsernameComponent : Identifie l'alli\u00e9 avec un nom unique.","title":"Interactions"},{"location":"entities/ally_entity/#exemples-dutilisation","text":"Cr\u00e9ation d'un alli\u00e9 : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); AllyEntity::createAllyEntity(entityManager, 100.0f, 200.0f, \"Ally1\", font); Mise \u00e0 jour de la position : cpp auto *position = allyEntity.getComponent<PositionComponent>(); if (position) { position->position.x += 10.0f; } AllyEntity fournit une base solide pour g\u00e9rer les entit\u00e9s alli\u00e9es dans le jeu, offrant des fonctionnalit\u00e9s visuelles et des interactions conviviales pour le joueur.","title":"Exemples d'Utilisation"},{"location":"entities/button_entity/","text":"ButtonEntity Introduction ButtonEntity repr\u00e9sente une entit\u00e9 interactive utilis\u00e9e pour cr\u00e9er des boutons dans l'interface du jeu. Elle permet d'associer des \u00e9v\u00e9nements et des actions sp\u00e9cifiques, comme des clics de souris. R\u00f4le dans l'ECS ButtonEntity est utilis\u00e9 pour : Afficher des boutons interactifs. R\u00e9agir aux \u00e9v\u00e9nements de la souris, comme les clics ou le survol. Fournir une base pour cr\u00e9er des interfaces utilisateur dynamiques. Attributs Les entit\u00e9s boutons sont cr\u00e9\u00e9es avec les composants suivants : HoverComponent : Change l'apparence du bouton lorsqu'il est survol\u00e9 par la souris. RectangleShapeComponent : D\u00e9finit la forme et l'apparence visuelle du bouton. TextComponent : Affiche le texte du bouton. EventHandlerComponent : Associe des \u00e9v\u00e9nements (clics de souris, survol, etc.) \u00e0 des callbacks sp\u00e9cifiques. Exemple de cr\u00e9ation Code extrait de ButtonEntity.cpp : ButtonEntity::ButtonEntity(EntityManager &entityManager, sf::Vector2f size, sf::Vector2f position, const std::string &text, const sf::Font &font) : entityManager_(entityManager), entity_(entityManager.createEntity()) { entity_.addComponent<HoverComponent>(sf::Color(128, 128, 128), sf::Color(128, 128, 128, 128)); entity_.addComponent<RectangleShapeComponent>(size, position, sf::Color(128, 128, 128)); entity_.addComponent<TextComponent>(text, font, position, sf::Color::White); } void ButtonEntity::setCallback(sf::Event::EventType eventType, EventHandlerComponent::callbackFunction callback) { auto *eventHandlerComponent = entity_.getComponent<EventHandlerComponent>(); if (!eventHandlerComponent) eventHandlerComponent = &entity_.addComponent<EventHandlerComponent>(eventType, callback); eventHandlerComponent->setCallback(eventType, callback); } Interactions Avec HoverSystem : Change la couleur du bouton lorsqu'il est survol\u00e9. Avec EventHandlingSystem : Ex\u00e9cute les callbacks associ\u00e9s lorsqu'un \u00e9v\u00e9nement est d\u00e9tect\u00e9. Avec RenderSystem : Affiche le bouton et son texte \u00e0 l'\u00e9cran. Exemples d'Utilisation Cr\u00e9ation d'un bouton : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); ButtonEntity button(entityManager, sf::Vector2f(150, 50), sf::Vector2f(300, 400), \"Play\", font); Ajout d'un callback : cpp button.setCallback(sf::Event::MouseButtonReleased, [](const sf::Event &event) { std::cout << \"Bouton cliqu\u00e9 !\" << std::endl; }); ButtonEntity est un outil essentiel pour cr\u00e9er des interfaces interactives dans le jeu, permettant des interactions fluides et dynamiques avec les utilisateurs.","title":"ButtonEntity"},{"location":"entities/button_entity/#buttonentity","text":"","title":"ButtonEntity"},{"location":"entities/button_entity/#introduction","text":"ButtonEntity repr\u00e9sente une entit\u00e9 interactive utilis\u00e9e pour cr\u00e9er des boutons dans l'interface du jeu. Elle permet d'associer des \u00e9v\u00e9nements et des actions sp\u00e9cifiques, comme des clics de souris.","title":"Introduction"},{"location":"entities/button_entity/#role-dans-lecs","text":"ButtonEntity est utilis\u00e9 pour : Afficher des boutons interactifs. R\u00e9agir aux \u00e9v\u00e9nements de la souris, comme les clics ou le survol. Fournir une base pour cr\u00e9er des interfaces utilisateur dynamiques.","title":"R\u00f4le dans l'ECS"},{"location":"entities/button_entity/#attributs","text":"Les entit\u00e9s boutons sont cr\u00e9\u00e9es avec les composants suivants : HoverComponent : Change l'apparence du bouton lorsqu'il est survol\u00e9 par la souris. RectangleShapeComponent : D\u00e9finit la forme et l'apparence visuelle du bouton. TextComponent : Affiche le texte du bouton. EventHandlerComponent : Associe des \u00e9v\u00e9nements (clics de souris, survol, etc.) \u00e0 des callbacks sp\u00e9cifiques.","title":"Attributs"},{"location":"entities/button_entity/#exemple-de-creation","text":"","title":"Exemple de cr\u00e9ation"},{"location":"entities/button_entity/#code-extrait-de-buttonentitycpp","text":"ButtonEntity::ButtonEntity(EntityManager &entityManager, sf::Vector2f size, sf::Vector2f position, const std::string &text, const sf::Font &font) : entityManager_(entityManager), entity_(entityManager.createEntity()) { entity_.addComponent<HoverComponent>(sf::Color(128, 128, 128), sf::Color(128, 128, 128, 128)); entity_.addComponent<RectangleShapeComponent>(size, position, sf::Color(128, 128, 128)); entity_.addComponent<TextComponent>(text, font, position, sf::Color::White); } void ButtonEntity::setCallback(sf::Event::EventType eventType, EventHandlerComponent::callbackFunction callback) { auto *eventHandlerComponent = entity_.getComponent<EventHandlerComponent>(); if (!eventHandlerComponent) eventHandlerComponent = &entity_.addComponent<EventHandlerComponent>(eventType, callback); eventHandlerComponent->setCallback(eventType, callback); }","title":"Code extrait de ButtonEntity.cpp :"},{"location":"entities/button_entity/#interactions","text":"Avec HoverSystem : Change la couleur du bouton lorsqu'il est survol\u00e9. Avec EventHandlingSystem : Ex\u00e9cute les callbacks associ\u00e9s lorsqu'un \u00e9v\u00e9nement est d\u00e9tect\u00e9. Avec RenderSystem : Affiche le bouton et son texte \u00e0 l'\u00e9cran.","title":"Interactions"},{"location":"entities/button_entity/#exemples-dutilisation","text":"Cr\u00e9ation d'un bouton : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); ButtonEntity button(entityManager, sf::Vector2f(150, 50), sf::Vector2f(300, 400), \"Play\", font); Ajout d'un callback : cpp button.setCallback(sf::Event::MouseButtonReleased, [](const sf::Event &event) { std::cout << \"Bouton cliqu\u00e9 !\" << std::endl; }); ButtonEntity est un outil essentiel pour cr\u00e9er des interfaces interactives dans le jeu, permettant des interactions fluides et dynamiques avec les utilisateurs.","title":"Exemples d'Utilisation"},{"location":"entities/bydos_entity/","text":"BydosEntity Introduction BydosEntity repr\u00e9sente les ennemis principaux dans le jeu R-Type. Ces entit\u00e9s poss\u00e8dent des caract\u00e9ristiques sp\u00e9cifiques, telles que leur position, leur sprite et leur \u00e9tat de sant\u00e9, pour g\u00e9rer leur comportement dans le jeu. R\u00f4le dans l'ECS BydosEntity est utilis\u00e9 pour : Repr\u00e9senter les ennemis dans le jeu avec des propri\u00e9t\u00e9s sp\u00e9cifiques. Int\u00e9grer les composants n\u00e9cessaires pour le rendu, la gestion des collisions et les interactions avec les joueurs. G\u00e9rer les donn\u00e9es relatives \u00e0 la sant\u00e9 et \u00e0 l'identit\u00e9 unique des ennemis. Attributs Les entit\u00e9s BydosEntity sont cr\u00e9\u00e9es avec les composants suivants : PositionComponent : D\u00e9finit la position de l'ennemi. SpriteComponent : Affiche un sprite repr\u00e9sentant visuellement l'ennemi. EnnemyIdComponent : Identifie l'ennemi de mani\u00e8re unique. HealthComponent : G\u00e8re les points de vie de l'ennemi. Exemple de cr\u00e9ation Code extrait de BydosEntity.cpp : Entity &BydosEntity::createBydos(EntityManager &entityManager, float x, float y, const std::string &id, int health) { Entity &bydos = entityManager.createEntity(); bydos.addComponent<PositionComponent>(x, y); bydos.addComponent<SpriteComponent>(\"assets/Bydos64x64.png\", sf::Vector2f(1, 1)); bydos.addComponent<EnnemyIdComponent>(id); bydos.addComponent<HealthComponent>(health); return bydos; } Interactions Avec MovementSystem : G\u00e8re les d\u00e9placements des ennemis dans le jeu. Avec RenderSystem : Affiche les sprites des ennemis \u00e0 l'\u00e9cran. Avec CollisionSystem : D\u00e9tecte les interactions avec les projectiles ou les joueurs. Avec HealthComponent : Permet de r\u00e9duire les points de vie des ennemis en cas de collision ou de d\u00e9g\u00e2ts. Exemples d'Utilisation Cr\u00e9ation d'un ennemi : cpp BydosEntity::createBydos(entityManager, 500.0f, 300.0f, \"enemy_001\", 100); Mise \u00e0 jour de la position : cpp auto *position = enemy.getComponent<PositionComponent>(); if (position) { position->position.x -= 5.0f; } R\u00e9duction des points de vie : cpp auto *health = enemy.getComponent<HealthComponent>(); if (health) { health->health -= 20; if (health->health <= 0) { entityManager.markForDeletion(enemy.getId()); } } BydosEntity est une entit\u00e9 centrale pour impl\u00e9menter les ennemis dans le jeu, avec des fonctionnalit\u00e9s adapt\u00e9es pour les interactions et les comportements sp\u00e9cifiques \u00e0 R-Type.","title":"BydosEntity"},{"location":"entities/bydos_entity/#bydosentity","text":"","title":"BydosEntity"},{"location":"entities/bydos_entity/#introduction","text":"BydosEntity repr\u00e9sente les ennemis principaux dans le jeu R-Type. Ces entit\u00e9s poss\u00e8dent des caract\u00e9ristiques sp\u00e9cifiques, telles que leur position, leur sprite et leur \u00e9tat de sant\u00e9, pour g\u00e9rer leur comportement dans le jeu.","title":"Introduction"},{"location":"entities/bydos_entity/#role-dans-lecs","text":"BydosEntity est utilis\u00e9 pour : Repr\u00e9senter les ennemis dans le jeu avec des propri\u00e9t\u00e9s sp\u00e9cifiques. Int\u00e9grer les composants n\u00e9cessaires pour le rendu, la gestion des collisions et les interactions avec les joueurs. G\u00e9rer les donn\u00e9es relatives \u00e0 la sant\u00e9 et \u00e0 l'identit\u00e9 unique des ennemis.","title":"R\u00f4le dans l'ECS"},{"location":"entities/bydos_entity/#attributs","text":"Les entit\u00e9s BydosEntity sont cr\u00e9\u00e9es avec les composants suivants : PositionComponent : D\u00e9finit la position de l'ennemi. SpriteComponent : Affiche un sprite repr\u00e9sentant visuellement l'ennemi. EnnemyIdComponent : Identifie l'ennemi de mani\u00e8re unique. HealthComponent : G\u00e8re les points de vie de l'ennemi.","title":"Attributs"},{"location":"entities/bydos_entity/#exemple-de-creation","text":"","title":"Exemple de cr\u00e9ation"},{"location":"entities/bydos_entity/#code-extrait-de-bydosentitycpp","text":"Entity &BydosEntity::createBydos(EntityManager &entityManager, float x, float y, const std::string &id, int health) { Entity &bydos = entityManager.createEntity(); bydos.addComponent<PositionComponent>(x, y); bydos.addComponent<SpriteComponent>(\"assets/Bydos64x64.png\", sf::Vector2f(1, 1)); bydos.addComponent<EnnemyIdComponent>(id); bydos.addComponent<HealthComponent>(health); return bydos; }","title":"Code extrait de BydosEntity.cpp :"},{"location":"entities/bydos_entity/#interactions","text":"Avec MovementSystem : G\u00e8re les d\u00e9placements des ennemis dans le jeu. Avec RenderSystem : Affiche les sprites des ennemis \u00e0 l'\u00e9cran. Avec CollisionSystem : D\u00e9tecte les interactions avec les projectiles ou les joueurs. Avec HealthComponent : Permet de r\u00e9duire les points de vie des ennemis en cas de collision ou de d\u00e9g\u00e2ts.","title":"Interactions"},{"location":"entities/bydos_entity/#exemples-dutilisation","text":"Cr\u00e9ation d'un ennemi : cpp BydosEntity::createBydos(entityManager, 500.0f, 300.0f, \"enemy_001\", 100); Mise \u00e0 jour de la position : cpp auto *position = enemy.getComponent<PositionComponent>(); if (position) { position->position.x -= 5.0f; } R\u00e9duction des points de vie : cpp auto *health = enemy.getComponent<HealthComponent>(); if (health) { health->health -= 20; if (health->health <= 0) { entityManager.markForDeletion(enemy.getId()); } } BydosEntity est une entit\u00e9 centrale pour impl\u00e9menter les ennemis dans le jeu, avec des fonctionnalit\u00e9s adapt\u00e9es pour les interactions et les comportements sp\u00e9cifiques \u00e0 R-Type.","title":"Exemples d'Utilisation"},{"location":"entities/menu_entity/","text":"MenuEntity Introduction MenuEntity repr\u00e9sente les interfaces utilisateur du jeu, telles que les menus principaux ou les \u00e9crans de param\u00e8tres. Elle fournit des boutons interactifs et des champs de texte permettant aux joueurs d'interagir avec le jeu. R\u00f4le dans l'ECS MenuEntity est utilis\u00e9 pour : Construire et g\u00e9rer les menus interactifs. Fournir des interfaces conviviales avec des boutons et des champs de texte. Connecter les interactions utilisateur avec les fonctionnalit\u00e9s du jeu. Attributs Les entit\u00e9s MenuEntity sont compos\u00e9es des \u00e9l\u00e9ments suivants : Boutons : Des instances de ButtonEntity pour g\u00e9rer les actions interactives. Champs de texte : Des instances de TextFieldEntity pour saisir ou afficher des informations. EventHandlerComponent : Pour g\u00e9rer les \u00e9v\u00e9nements utilisateur (par exemple, appuyer sur des touches ou cliquer sur un bouton). Exemple de cr\u00e9ation Code extrait de MenuEntity.cpp : MenuEntity::MenuEntity(EntityManager &entityManager, sf::RenderWindow &window, const sf::Font &font, std::unique_ptr<PlayerEntity> &player, NetworkManager &networkManager) : entity_(entityManager.createEntity()), entityManager_(entityManager), networkManager_(networkManager), window_(window), font_(font), player_(player) { open(); entity_.addComponent<EventHandlerComponent>(sf::Event::KeyReleased, [this, &window](const sf::Event &event) { EventCallbacks::MenuToggle(event, window, *this); }); } Interactions Avec ButtonEntity : Les boutons sont des \u00e9l\u00e9ments cl\u00e9s des menus et d\u00e9clenchent des actions sp\u00e9cifiques (comme \"Jouer\" ou \"Quitter\"). Avec TextFieldEntity : Permet d'entrer des informations utilisateur, telles que l'adresse IP ou le nom d'utilisateur. Avec RenderSystem : Affiche les menus et leurs \u00e9l\u00e9ments visuels \u00e0 l'\u00e9cran. Fonctionnalit\u00e9s principales Gestion des boutons et des champs de texte Les boutons et champs de texte sont ajout\u00e9s dynamiquement au menu. Par exemple : void MenuEntity::open() { sf::Vector2f size(150, 50); sf::Vector2f position(window_.getSize().x / 2.0f - 300, 500); buttons_.push_back(std::make_unique<ButtonEntity>(entityManager_, size, position, \"Play\", font_)); buttons_[0]->setCallback(sf::Event::MouseButtonReleased, [this](const sf::Event &event) { EventCallbacks::ButtonHandlePlay( *this, buttons_[0]->getEntity(), window_, event, entityManager_, player_, networkManager_); }); } Exemples d'Utilisation Cr\u00e9ation d'un menu : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); MenuEntity menu(entityManager, window, font, playerEntity, networkManager); Ajout d'un champ de texte : cpp position.x = 400; position.y = 300; auto textField = std::make_unique<TextFieldEntity>(entityManager, window, sf::Vector2f(200, 50), position, font, \"Enter Name:\"); Gestion dynamique Le menu peut \u00eatre ouvert et ferm\u00e9 dynamiquement, en cr\u00e9ant ou supprimant ses \u00e9l\u00e9ments selon les besoins. MenuEntity fournit une infrastructure robuste pour cr\u00e9er des menus interactifs dans le jeu, facilitant les interactions utilisateur avec des \u00e9l\u00e9ments intuitifs et personnalisables.","title":"MenuEntity"},{"location":"entities/menu_entity/#menuentity","text":"","title":"MenuEntity"},{"location":"entities/menu_entity/#introduction","text":"MenuEntity repr\u00e9sente les interfaces utilisateur du jeu, telles que les menus principaux ou les \u00e9crans de param\u00e8tres. Elle fournit des boutons interactifs et des champs de texte permettant aux joueurs d'interagir avec le jeu.","title":"Introduction"},{"location":"entities/menu_entity/#role-dans-lecs","text":"MenuEntity est utilis\u00e9 pour : Construire et g\u00e9rer les menus interactifs. Fournir des interfaces conviviales avec des boutons et des champs de texte. Connecter les interactions utilisateur avec les fonctionnalit\u00e9s du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"entities/menu_entity/#attributs","text":"Les entit\u00e9s MenuEntity sont compos\u00e9es des \u00e9l\u00e9ments suivants : Boutons : Des instances de ButtonEntity pour g\u00e9rer les actions interactives. Champs de texte : Des instances de TextFieldEntity pour saisir ou afficher des informations. EventHandlerComponent : Pour g\u00e9rer les \u00e9v\u00e9nements utilisateur (par exemple, appuyer sur des touches ou cliquer sur un bouton).","title":"Attributs"},{"location":"entities/menu_entity/#exemple-de-creation","text":"","title":"Exemple de cr\u00e9ation"},{"location":"entities/menu_entity/#code-extrait-de-menuentitycpp","text":"MenuEntity::MenuEntity(EntityManager &entityManager, sf::RenderWindow &window, const sf::Font &font, std::unique_ptr<PlayerEntity> &player, NetworkManager &networkManager) : entity_(entityManager.createEntity()), entityManager_(entityManager), networkManager_(networkManager), window_(window), font_(font), player_(player) { open(); entity_.addComponent<EventHandlerComponent>(sf::Event::KeyReleased, [this, &window](const sf::Event &event) { EventCallbacks::MenuToggle(event, window, *this); }); }","title":"Code extrait de MenuEntity.cpp :"},{"location":"entities/menu_entity/#interactions","text":"Avec ButtonEntity : Les boutons sont des \u00e9l\u00e9ments cl\u00e9s des menus et d\u00e9clenchent des actions sp\u00e9cifiques (comme \"Jouer\" ou \"Quitter\"). Avec TextFieldEntity : Permet d'entrer des informations utilisateur, telles que l'adresse IP ou le nom d'utilisateur. Avec RenderSystem : Affiche les menus et leurs \u00e9l\u00e9ments visuels \u00e0 l'\u00e9cran.","title":"Interactions"},{"location":"entities/menu_entity/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"entities/menu_entity/#gestion-des-boutons-et-des-champs-de-texte","text":"Les boutons et champs de texte sont ajout\u00e9s dynamiquement au menu. Par exemple : void MenuEntity::open() { sf::Vector2f size(150, 50); sf::Vector2f position(window_.getSize().x / 2.0f - 300, 500); buttons_.push_back(std::make_unique<ButtonEntity>(entityManager_, size, position, \"Play\", font_)); buttons_[0]->setCallback(sf::Event::MouseButtonReleased, [this](const sf::Event &event) { EventCallbacks::ButtonHandlePlay( *this, buttons_[0]->getEntity(), window_, event, entityManager_, player_, networkManager_); }); }","title":"Gestion des boutons et des champs de texte"},{"location":"entities/menu_entity/#exemples-dutilisation","text":"Cr\u00e9ation d'un menu : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); MenuEntity menu(entityManager, window, font, playerEntity, networkManager); Ajout d'un champ de texte : cpp position.x = 400; position.y = 300; auto textField = std::make_unique<TextFieldEntity>(entityManager, window, sf::Vector2f(200, 50), position, font, \"Enter Name:\");","title":"Exemples d'Utilisation"},{"location":"entities/menu_entity/#gestion-dynamique","text":"Le menu peut \u00eatre ouvert et ferm\u00e9 dynamiquement, en cr\u00e9ant ou supprimant ses \u00e9l\u00e9ments selon les besoins. MenuEntity fournit une infrastructure robuste pour cr\u00e9er des menus interactifs dans le jeu, facilitant les interactions utilisateur avec des \u00e9l\u00e9ments intuitifs et personnalisables.","title":"Gestion dynamique"},{"location":"entities/player_entity/","text":"PlayerEntity Introduction PlayerEntity repr\u00e9sente le joueur dans le jeu. Cette entit\u00e9 contient des composants qui permettent de g\u00e9rer l'apparence, les entr\u00e9es utilisateur, le son, et les interactions r\u00e9seau pour le joueur. R\u00f4le dans l'ECS PlayerEntity est utilis\u00e9 pour : Repr\u00e9senter le joueur avec une position et un sprite visuel. G\u00e9rer les interactions du joueur \u00e0 travers les entr\u00e9es clavier. Jouer des sons associ\u00e9s au joueur. Synchroniser les actions du joueur avec le serveur. Attributs Les entit\u00e9s PlayerEntity sont cr\u00e9\u00e9es avec les composants suivants : PositionComponent : D\u00e9finit la position initiale du joueur. SpriteComponent : Repr\u00e9sente graphiquement le joueur avec un sprite. InputComponent : Capture les entr\u00e9es utilisateur pour contr\u00f4ler le joueur. UsernameComponent : Identifie le joueur par un nom unique. SoundComponent : Ajoute des effets sonores li\u00e9s au joueur. Exemple de cr\u00e9ation Code extrait de PlayerEntity.cpp : PlayerEntity::PlayerEntity(EntityManager &entityManager, const std::string &username, NetworkManager &networkManager) : entityManager_(entityManager), entity_(entityManager.createEntity()) { entity_.addComponent<PositionComponent>(400, 300); entity_.addComponent<SpriteComponent>(\"assets/Player64x64.png\", sf::Vector2f(1, 1)); entity_.addComponent<InputComponent>(); entity_.addComponent<UsernameComponent>(username); auto &sound = entity_.addComponent<SoundComponent>(\"assets/spaceshipIdle.mp3\", -1); sound.sound.setPitch(0.5); networkManager.send(MessageType::CONNECT, username); } Interactions Avec InputSystem : Utilise les entr\u00e9es utilisateur pour contr\u00f4ler les mouvements et les actions du joueur. Avec MovementSystem : Met \u00e0 jour la position du joueur en fonction des entr\u00e9es. Avec RenderSystem : Affiche le sprite et les informations associ\u00e9es au joueur. Avec SoundSystem : Joue les sons li\u00e9s aux actions du joueur. Exemples d'Utilisation Cr\u00e9ation d'un joueur : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); PlayerEntity player(entityManager, \"Player1\", networkManager); Mise \u00e0 jour de la position : cpp auto *position = playerEntity.getComponent<PositionComponent>(); if (position) { position->position.x += 10.0f; } R\u00e9agir aux entr\u00e9es utilisateur : cpp auto *input = playerEntity.getComponent<InputComponent>(); if (input && input->moveLeft) { std::cout << \"D\u00e9placement vers la gauche !\" << std::endl; } Fonctionnalit\u00e9s principales Gestion des entr\u00e9es : Capture et traite les actions du joueur. Synchronisation r\u00e9seau : Transmet les actions du joueur au serveur. Effets sonores : Joue des sons contextuels li\u00e9s au joueur. PlayerEntity est une entit\u00e9 cl\u00e9 qui permet de repr\u00e9senter et de g\u00e9rer le joueur dans le jeu, en int\u00e9grant des interactions visuelles, sonores et r\u00e9seau.","title":"PlayerEntity"},{"location":"entities/player_entity/#playerentity","text":"","title":"PlayerEntity"},{"location":"entities/player_entity/#introduction","text":"PlayerEntity repr\u00e9sente le joueur dans le jeu. Cette entit\u00e9 contient des composants qui permettent de g\u00e9rer l'apparence, les entr\u00e9es utilisateur, le son, et les interactions r\u00e9seau pour le joueur.","title":"Introduction"},{"location":"entities/player_entity/#role-dans-lecs","text":"PlayerEntity est utilis\u00e9 pour : Repr\u00e9senter le joueur avec une position et un sprite visuel. G\u00e9rer les interactions du joueur \u00e0 travers les entr\u00e9es clavier. Jouer des sons associ\u00e9s au joueur. Synchroniser les actions du joueur avec le serveur.","title":"R\u00f4le dans l'ECS"},{"location":"entities/player_entity/#attributs","text":"Les entit\u00e9s PlayerEntity sont cr\u00e9\u00e9es avec les composants suivants : PositionComponent : D\u00e9finit la position initiale du joueur. SpriteComponent : Repr\u00e9sente graphiquement le joueur avec un sprite. InputComponent : Capture les entr\u00e9es utilisateur pour contr\u00f4ler le joueur. UsernameComponent : Identifie le joueur par un nom unique. SoundComponent : Ajoute des effets sonores li\u00e9s au joueur.","title":"Attributs"},{"location":"entities/player_entity/#exemple-de-creation","text":"","title":"Exemple de cr\u00e9ation"},{"location":"entities/player_entity/#code-extrait-de-playerentitycpp","text":"PlayerEntity::PlayerEntity(EntityManager &entityManager, const std::string &username, NetworkManager &networkManager) : entityManager_(entityManager), entity_(entityManager.createEntity()) { entity_.addComponent<PositionComponent>(400, 300); entity_.addComponent<SpriteComponent>(\"assets/Player64x64.png\", sf::Vector2f(1, 1)); entity_.addComponent<InputComponent>(); entity_.addComponent<UsernameComponent>(username); auto &sound = entity_.addComponent<SoundComponent>(\"assets/spaceshipIdle.mp3\", -1); sound.sound.setPitch(0.5); networkManager.send(MessageType::CONNECT, username); }","title":"Code extrait de PlayerEntity.cpp :"},{"location":"entities/player_entity/#interactions","text":"Avec InputSystem : Utilise les entr\u00e9es utilisateur pour contr\u00f4ler les mouvements et les actions du joueur. Avec MovementSystem : Met \u00e0 jour la position du joueur en fonction des entr\u00e9es. Avec RenderSystem : Affiche le sprite et les informations associ\u00e9es au joueur. Avec SoundSystem : Joue les sons li\u00e9s aux actions du joueur.","title":"Interactions"},{"location":"entities/player_entity/#exemples-dutilisation","text":"Cr\u00e9ation d'un joueur : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); PlayerEntity player(entityManager, \"Player1\", networkManager); Mise \u00e0 jour de la position : cpp auto *position = playerEntity.getComponent<PositionComponent>(); if (position) { position->position.x += 10.0f; } R\u00e9agir aux entr\u00e9es utilisateur : cpp auto *input = playerEntity.getComponent<InputComponent>(); if (input && input->moveLeft) { std::cout << \"D\u00e9placement vers la gauche !\" << std::endl; }","title":"Exemples d'Utilisation"},{"location":"entities/player_entity/#fonctionnalites-principales","text":"Gestion des entr\u00e9es : Capture et traite les actions du joueur. Synchronisation r\u00e9seau : Transmet les actions du joueur au serveur. Effets sonores : Joue des sons contextuels li\u00e9s au joueur. PlayerEntity est une entit\u00e9 cl\u00e9 qui permet de repr\u00e9senter et de g\u00e9rer le joueur dans le jeu, en int\u00e9grant des interactions visuelles, sonores et r\u00e9seau.","title":"Fonctionnalit\u00e9s principales"},{"location":"entities/text_field_entity/","text":"TextFieldEntity Introduction TextFieldEntity repr\u00e9sente un champ de texte interactif utilis\u00e9 dans les interfaces utilisateur du jeu. Cette entit\u00e9 permet d'afficher des titres, de saisir des informations et de capturer des interactions utilisateur pour des actions sp\u00e9cifiques. R\u00f4le dans l'ECS TextFieldEntity est utilis\u00e9 pour : Afficher et g\u00e9rer des champs de texte interactifs. Permettre \u00e0 l'utilisateur d'entrer des informations telles que des noms ou des adresses IP. Capturer et traiter les \u00e9v\u00e9nements clavier pour interagir avec le texte. Attributs Les entit\u00e9s TextFieldEntity sont cr\u00e9\u00e9es avec les composants suivants : RectangleShapeComponent : D\u00e9finit la forme et l'apparence visuelle du champ de texte. TextComponent : Affiche le texte principal et le titre associ\u00e9. HoverComponent : Modifie l'apparence lorsque la souris survole le champ de texte. SelectionComponent : Indique si le champ de texte est actuellement s\u00e9lectionn\u00e9 pour l'\u00e9dition. EventHandlerComponent : Capture les \u00e9v\u00e9nements clavier pour modifier le contenu du texte. Exemple de cr\u00e9ation Code extrait de TextFieldEntity.cpp : TextFieldEntity::TextFieldEntity(EntityManager &entityManager, sf::RenderWindow &window, sf::Vector2f size, sf::Vector2f position, const sf::Font &font, const std::string &title) : entity_(entityManager.createEntity()), titleEntity_(entityManager.createEntity()), entityManager_(entityManager), window_(window) { auto &eventHandlerComponent = entity_.addComponent<EventHandlerComponent>(sf::Event::KeyPressed, [this](const sf::Event &event) { EventCallbacks::TextFieldListener(event, window_, *this); }); eventHandlerComponent.setCallback(sf::Event::KeyReleased, [this](const sf::Event &event) { EventCallbacks::TextFieldCapsReleaseHandler(event, window_, *this); }); entity_.addComponent<RectangleShapeComponent>(size, position, sf::Color(128, 128, 128)); position.y -= size.y; titleEntity_.addComponent<TextComponent>(title, font, position, sf::Color(208, 208, 208)); position.y += size.y; entity_.addComponent<TextComponent>(\"\", font, position, sf::Color(228, 228, 228)); entity_.addComponent<SelectionComponent>(); entity_.addComponent<HoverComponent>(sf::Color(128, 128, 128), sf::Color(100, 100, 100)); conversion_ = 'a'; } Interactions Avec EventHandlingSystem : Capture les entr\u00e9es utilisateur et met \u00e0 jour le texte affich\u00e9. Avec HoverSystem : Change l'apparence visuelle en fonction des interactions avec la souris. Avec RenderSystem : Affiche le champ de texte et le titre associ\u00e9 \u00e0 l'\u00e9cran. Exemples d'Utilisation Cr\u00e9ation d'un champ de texte : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); TextFieldEntity textField(entityManager, window, sf::Vector2f(200, 50), sf::Vector2f(300, 400), font, \"Enter Name:\"); Mise \u00e0 jour du contenu textuel : cpp auto *textComponent = textField.getComponent<TextComponent>(); if (textComponent) { textComponent->data.setString(\"Player1\"); } S\u00e9lection et modification : cpp auto *selection = textField.getComponent<SelectionComponent>(); if (selection && selection->isSelected) { textField.addKey(sf::Keyboard::A); } Fonctionnalit\u00e9s principales Gestion des \u00e9v\u00e9nements clavier : Capture les entr\u00e9es utilisateur pour modifier dynamiquement le texte. Apparence interactive : Change visuellement en fonction de l'\u00e9tat de s\u00e9lection ou des interactions souris. Synchronisation avec d'autres entit\u00e9s : Affiche des informations pertinentes pour le joueur ou les param\u00e8tres du jeu. TextFieldEntity offre une solution puissante et flexible pour g\u00e9rer les champs de texte interactifs dans les menus ou interfaces utilisateur du jeu.","title":"TextFieldEntity"},{"location":"entities/text_field_entity/#textfieldentity","text":"","title":"TextFieldEntity"},{"location":"entities/text_field_entity/#introduction","text":"TextFieldEntity repr\u00e9sente un champ de texte interactif utilis\u00e9 dans les interfaces utilisateur du jeu. Cette entit\u00e9 permet d'afficher des titres, de saisir des informations et de capturer des interactions utilisateur pour des actions sp\u00e9cifiques.","title":"Introduction"},{"location":"entities/text_field_entity/#role-dans-lecs","text":"TextFieldEntity est utilis\u00e9 pour : Afficher et g\u00e9rer des champs de texte interactifs. Permettre \u00e0 l'utilisateur d'entrer des informations telles que des noms ou des adresses IP. Capturer et traiter les \u00e9v\u00e9nements clavier pour interagir avec le texte.","title":"R\u00f4le dans l'ECS"},{"location":"entities/text_field_entity/#attributs","text":"Les entit\u00e9s TextFieldEntity sont cr\u00e9\u00e9es avec les composants suivants : RectangleShapeComponent : D\u00e9finit la forme et l'apparence visuelle du champ de texte. TextComponent : Affiche le texte principal et le titre associ\u00e9. HoverComponent : Modifie l'apparence lorsque la souris survole le champ de texte. SelectionComponent : Indique si le champ de texte est actuellement s\u00e9lectionn\u00e9 pour l'\u00e9dition. EventHandlerComponent : Capture les \u00e9v\u00e9nements clavier pour modifier le contenu du texte.","title":"Attributs"},{"location":"entities/text_field_entity/#exemple-de-creation","text":"","title":"Exemple de cr\u00e9ation"},{"location":"entities/text_field_entity/#code-extrait-de-textfieldentitycpp","text":"TextFieldEntity::TextFieldEntity(EntityManager &entityManager, sf::RenderWindow &window, sf::Vector2f size, sf::Vector2f position, const sf::Font &font, const std::string &title) : entity_(entityManager.createEntity()), titleEntity_(entityManager.createEntity()), entityManager_(entityManager), window_(window) { auto &eventHandlerComponent = entity_.addComponent<EventHandlerComponent>(sf::Event::KeyPressed, [this](const sf::Event &event) { EventCallbacks::TextFieldListener(event, window_, *this); }); eventHandlerComponent.setCallback(sf::Event::KeyReleased, [this](const sf::Event &event) { EventCallbacks::TextFieldCapsReleaseHandler(event, window_, *this); }); entity_.addComponent<RectangleShapeComponent>(size, position, sf::Color(128, 128, 128)); position.y -= size.y; titleEntity_.addComponent<TextComponent>(title, font, position, sf::Color(208, 208, 208)); position.y += size.y; entity_.addComponent<TextComponent>(\"\", font, position, sf::Color(228, 228, 228)); entity_.addComponent<SelectionComponent>(); entity_.addComponent<HoverComponent>(sf::Color(128, 128, 128), sf::Color(100, 100, 100)); conversion_ = 'a'; }","title":"Code extrait de TextFieldEntity.cpp :"},{"location":"entities/text_field_entity/#interactions","text":"Avec EventHandlingSystem : Capture les entr\u00e9es utilisateur et met \u00e0 jour le texte affich\u00e9. Avec HoverSystem : Change l'apparence visuelle en fonction des interactions avec la souris. Avec RenderSystem : Affiche le champ de texte et le titre associ\u00e9 \u00e0 l'\u00e9cran.","title":"Interactions"},{"location":"entities/text_field_entity/#exemples-dutilisation","text":"Cr\u00e9ation d'un champ de texte : cpp sf::Font font; font.loadFromFile(\"assets/fonts/arial.ttf\"); TextFieldEntity textField(entityManager, window, sf::Vector2f(200, 50), sf::Vector2f(300, 400), font, \"Enter Name:\"); Mise \u00e0 jour du contenu textuel : cpp auto *textComponent = textField.getComponent<TextComponent>(); if (textComponent) { textComponent->data.setString(\"Player1\"); } S\u00e9lection et modification : cpp auto *selection = textField.getComponent<SelectionComponent>(); if (selection && selection->isSelected) { textField.addKey(sf::Keyboard::A); }","title":"Exemples d'Utilisation"},{"location":"entities/text_field_entity/#fonctionnalites-principales","text":"Gestion des \u00e9v\u00e9nements clavier : Capture les entr\u00e9es utilisateur pour modifier dynamiquement le texte. Apparence interactive : Change visuellement en fonction de l'\u00e9tat de s\u00e9lection ou des interactions souris. Synchronisation avec d'autres entit\u00e9s : Affiche des informations pertinentes pour le joueur ou les param\u00e8tres du jeu. TextFieldEntity offre une solution puissante et flexible pour g\u00e9rer les champs de texte interactifs dans les menus ou interfaces utilisateur du jeu.","title":"Fonctionnalit\u00e9s principales"},{"location":"managers/entity_manager/","text":"EntityManager Introduction Le gestionnaire d'entit\u00e9s, EntityManager , est un composant central du syst\u00e8me ECS. Il est responsable de la cr\u00e9ation, de la gestion et de la suppression des entit\u00e9s dans le jeu. R\u00f4le dans l'ECS EntityManager a pour r\u00f4le de : Cr\u00e9er des entit\u00e9s et leur attribuer un identifiant unique. G\u00e9rer les composants associ\u00e9s \u00e0 chaque entit\u00e9. Faciliter l'interaction entre les syst\u00e8mes et les entit\u00e9s. Supprimer les entit\u00e9s marqu\u00e9es pour suppression. Fonctionnalit\u00e9s principales M\u00e9thode createEntity Cr\u00e9e une nouvelle entit\u00e9 et la retourne. Exemple de code Entity &EntityManager::createEntity() { entities.push_back(std::make_unique<Entity>()); return *entities.back(); } M\u00e9thode markForDeletion Marque une entit\u00e9 pour suppression future. Exemple de code void EntityManager::markForDeletion(uint64_t id) { toBeDeleted.push_back(id); } M\u00e9thode destroyMarkedEntities Supprime les entit\u00e9s qui ont \u00e9t\u00e9 marqu\u00e9es pour suppression. Exemple de code void EntityManager::destroyMarkedEntities() { for (uint64_t id : toBeDeleted) { entities.erase(std::remove_if(entities.begin(), entities.end(), [id](const auto &e) { return e->getId() == id; }), entities.end()); } toBeDeleted.clear(); } Exemples d'Utilisation Cr\u00e9ation d'une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<PositionComponent>(100.0f, 200.0f); player.addComponent<HealthComponent>(100, 100); Suppression d'une entit\u00e9 : cpp entityManager.markForDeletion(player.getId()); entityManager.destroyMarkedEntities(); Interactions Avec les syst\u00e8mes ECS : Les syst\u00e8mes acc\u00e8dent aux entit\u00e9s via EntityManager pour ex\u00e9cuter leurs op\u00e9rations. Avec les composants : G\u00e8re les composants associ\u00e9s \u00e0 chaque entit\u00e9. Points forts Gestion centralis\u00e9e : Toutes les entit\u00e9s sont g\u00e9r\u00e9es au m\u00eame endroit, ce qui facilite leur manipulation. Flexibilit\u00e9 : Permet d'ajouter ou de supprimer des entit\u00e9s dynamiquement au cours du jeu. EntityManager est un \u00e9l\u00e9ment crucial de l'architecture ECS, offrant une gestion efficace et centralis\u00e9e des entit\u00e9s dans le jeu.","title":"EntityManager"},{"location":"managers/entity_manager/#entitymanager","text":"","title":"EntityManager"},{"location":"managers/entity_manager/#introduction","text":"Le gestionnaire d'entit\u00e9s, EntityManager , est un composant central du syst\u00e8me ECS. Il est responsable de la cr\u00e9ation, de la gestion et de la suppression des entit\u00e9s dans le jeu.","title":"Introduction"},{"location":"managers/entity_manager/#role-dans-lecs","text":"EntityManager a pour r\u00f4le de : Cr\u00e9er des entit\u00e9s et leur attribuer un identifiant unique. G\u00e9rer les composants associ\u00e9s \u00e0 chaque entit\u00e9. Faciliter l'interaction entre les syst\u00e8mes et les entit\u00e9s. Supprimer les entit\u00e9s marqu\u00e9es pour suppression.","title":"R\u00f4le dans l'ECS"},{"location":"managers/entity_manager/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"managers/entity_manager/#methode-createentity","text":"Cr\u00e9e une nouvelle entit\u00e9 et la retourne.","title":"M\u00e9thode createEntity"},{"location":"managers/entity_manager/#exemple-de-code","text":"Entity &EntityManager::createEntity() { entities.push_back(std::make_unique<Entity>()); return *entities.back(); }","title":"Exemple de code"},{"location":"managers/entity_manager/#methode-markfordeletion","text":"Marque une entit\u00e9 pour suppression future.","title":"M\u00e9thode markForDeletion"},{"location":"managers/entity_manager/#exemple-de-code_1","text":"void EntityManager::markForDeletion(uint64_t id) { toBeDeleted.push_back(id); }","title":"Exemple de code"},{"location":"managers/entity_manager/#methode-destroymarkedentities","text":"Supprime les entit\u00e9s qui ont \u00e9t\u00e9 marqu\u00e9es pour suppression.","title":"M\u00e9thode destroyMarkedEntities"},{"location":"managers/entity_manager/#exemple-de-code_2","text":"void EntityManager::destroyMarkedEntities() { for (uint64_t id : toBeDeleted) { entities.erase(std::remove_if(entities.begin(), entities.end(), [id](const auto &e) { return e->getId() == id; }), entities.end()); } toBeDeleted.clear(); }","title":"Exemple de code"},{"location":"managers/entity_manager/#exemples-dutilisation","text":"Cr\u00e9ation d'une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<PositionComponent>(100.0f, 200.0f); player.addComponent<HealthComponent>(100, 100); Suppression d'une entit\u00e9 : cpp entityManager.markForDeletion(player.getId()); entityManager.destroyMarkedEntities();","title":"Exemples d'Utilisation"},{"location":"managers/entity_manager/#interactions","text":"Avec les syst\u00e8mes ECS : Les syst\u00e8mes acc\u00e8dent aux entit\u00e9s via EntityManager pour ex\u00e9cuter leurs op\u00e9rations. Avec les composants : G\u00e8re les composants associ\u00e9s \u00e0 chaque entit\u00e9.","title":"Interactions"},{"location":"managers/entity_manager/#points-forts","text":"Gestion centralis\u00e9e : Toutes les entit\u00e9s sont g\u00e9r\u00e9es au m\u00eame endroit, ce qui facilite leur manipulation. Flexibilit\u00e9 : Permet d'ajouter ou de supprimer des entit\u00e9s dynamiquement au cours du jeu. EntityManager est un \u00e9l\u00e9ment crucial de l'architecture ECS, offrant une gestion efficace et centralis\u00e9e des entit\u00e9s dans le jeu.","title":"Points forts"},{"location":"managers/network_manager/","text":"NetworkManager Introduction Le gestionnaire r\u00e9seau, NetworkManager , est charg\u00e9 de g\u00e9rer les communications entre le client et le serveur. Il envoie et re\u00e7oit des messages pour synchroniser l'\u00e9tat du jeu entre les diff\u00e9rentes instances. R\u00f4le dans l'ECS NetworkManager a pour r\u00f4le de : Envoyer des messages du client vers le serveur. Recevoir et traiter les messages envoy\u00e9s par le serveur. Assurer une gestion fluide des communications r\u00e9seau, m\u00eame en cas d'erreurs ou de pertes de paquets. Fonctionnalit\u00e9s principales Constructeur NetworkManager Initialise le gestionnaire r\u00e9seau avec une adresse IP de serveur et un port. Exemple de code NetworkManager::NetworkManager(const std::string &serverIp, uint16_t port) : serverIp(serverIp), serverPort(port) { if (socket.bind(sf::Socket::AnyPort) != sf::Socket::Done) { throw std::runtime_error(\"Failed to bind socket\"); } receiverThread = std::thread(&NetworkManager::receiveMessages, this); } M\u00e9thode send Envoie un message au serveur. Exemple de code void NetworkManager::send(const std::string &buffer) { socket.send(buffer.data(), buffer.size(), serverIp, serverPort); } M\u00e9thode getReceivedMessages R\u00e9cup\u00e8re les messages re\u00e7us. Exemple de code std::queue<std::string> &NetworkManager::getReceivedMessages() { std::lock_guard<std::mutex> lock(queueMutex); return receivedMessages; } M\u00e9thode receiveMessages \u00c9coute les messages entrants et les stocke dans une file d'attente. Exemple de code void NetworkManager::receiveMessages() { char data[1024]; std::size_t received; sf::IpAddress sender; unsigned short senderPort; while (true) { if (socket.receive(data, sizeof(data), received, sender, senderPort) == sf::Socket::Done) { std::lock_guard<std::mutex> lock(queueMutex); receivedMessages.push(std::string(data, received)); } } } Exemples d'Utilisation Initialisation du gestionnaire r\u00e9seau : cpp NetworkManager networkManager(\"127.0.0.1\", 54000); Envoi d'un message : cpp std::string message = \"Hello, server!\"; networkManager.send(message); R\u00e9cup\u00e9ration des messages re\u00e7us : cpp auto &messages = networkManager.getReceivedMessages(); while (!messages.empty()) { std::cout << \"Message re\u00e7u : \" << messages.front() << std::endl; messages.pop(); } Interactions Avec MessageSystem : Fournit les donn\u00e9es r\u00e9seau n\u00e9cessaires pour mettre \u00e0 jour les entit\u00e9s. Avec Serializer : Encode et d\u00e9code les messages pour assurer leur compatibilit\u00e9 avec le protocole r\u00e9seau. Points forts Multithread\u00e9 : G\u00e8re les envois et r\u00e9ceptions de mani\u00e8re asynchrone pour \u00e9viter de bloquer le jeu. Robuste : G\u00e8re les erreurs r\u00e9seau pour assurer une exp\u00e9rience fluide. NetworkManager est un composant essentiel pour les jeux multijoueurs, garantissant des communications r\u00e9seau fiables et efficaces entre les clients et le serveur.","title":"NetworkManager"},{"location":"managers/network_manager/#networkmanager","text":"","title":"NetworkManager"},{"location":"managers/network_manager/#introduction","text":"Le gestionnaire r\u00e9seau, NetworkManager , est charg\u00e9 de g\u00e9rer les communications entre le client et le serveur. Il envoie et re\u00e7oit des messages pour synchroniser l'\u00e9tat du jeu entre les diff\u00e9rentes instances.","title":"Introduction"},{"location":"managers/network_manager/#role-dans-lecs","text":"NetworkManager a pour r\u00f4le de : Envoyer des messages du client vers le serveur. Recevoir et traiter les messages envoy\u00e9s par le serveur. Assurer une gestion fluide des communications r\u00e9seau, m\u00eame en cas d'erreurs ou de pertes de paquets.","title":"R\u00f4le dans l'ECS"},{"location":"managers/network_manager/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"managers/network_manager/#constructeur-networkmanager","text":"Initialise le gestionnaire r\u00e9seau avec une adresse IP de serveur et un port.","title":"Constructeur NetworkManager"},{"location":"managers/network_manager/#exemple-de-code","text":"NetworkManager::NetworkManager(const std::string &serverIp, uint16_t port) : serverIp(serverIp), serverPort(port) { if (socket.bind(sf::Socket::AnyPort) != sf::Socket::Done) { throw std::runtime_error(\"Failed to bind socket\"); } receiverThread = std::thread(&NetworkManager::receiveMessages, this); }","title":"Exemple de code"},{"location":"managers/network_manager/#methode-send","text":"Envoie un message au serveur.","title":"M\u00e9thode send"},{"location":"managers/network_manager/#exemple-de-code_1","text":"void NetworkManager::send(const std::string &buffer) { socket.send(buffer.data(), buffer.size(), serverIp, serverPort); }","title":"Exemple de code"},{"location":"managers/network_manager/#methode-getreceivedmessages","text":"R\u00e9cup\u00e8re les messages re\u00e7us.","title":"M\u00e9thode getReceivedMessages"},{"location":"managers/network_manager/#exemple-de-code_2","text":"std::queue<std::string> &NetworkManager::getReceivedMessages() { std::lock_guard<std::mutex> lock(queueMutex); return receivedMessages; }","title":"Exemple de code"},{"location":"managers/network_manager/#methode-receivemessages","text":"\u00c9coute les messages entrants et les stocke dans une file d'attente.","title":"M\u00e9thode receiveMessages"},{"location":"managers/network_manager/#exemple-de-code_3","text":"void NetworkManager::receiveMessages() { char data[1024]; std::size_t received; sf::IpAddress sender; unsigned short senderPort; while (true) { if (socket.receive(data, sizeof(data), received, sender, senderPort) == sf::Socket::Done) { std::lock_guard<std::mutex> lock(queueMutex); receivedMessages.push(std::string(data, received)); } } }","title":"Exemple de code"},{"location":"managers/network_manager/#exemples-dutilisation","text":"Initialisation du gestionnaire r\u00e9seau : cpp NetworkManager networkManager(\"127.0.0.1\", 54000); Envoi d'un message : cpp std::string message = \"Hello, server!\"; networkManager.send(message); R\u00e9cup\u00e9ration des messages re\u00e7us : cpp auto &messages = networkManager.getReceivedMessages(); while (!messages.empty()) { std::cout << \"Message re\u00e7u : \" << messages.front() << std::endl; messages.pop(); }","title":"Exemples d'Utilisation"},{"location":"managers/network_manager/#interactions","text":"Avec MessageSystem : Fournit les donn\u00e9es r\u00e9seau n\u00e9cessaires pour mettre \u00e0 jour les entit\u00e9s. Avec Serializer : Encode et d\u00e9code les messages pour assurer leur compatibilit\u00e9 avec le protocole r\u00e9seau.","title":"Interactions"},{"location":"managers/network_manager/#points-forts","text":"Multithread\u00e9 : G\u00e8re les envois et r\u00e9ceptions de mani\u00e8re asynchrone pour \u00e9viter de bloquer le jeu. Robuste : G\u00e8re les erreurs r\u00e9seau pour assurer une exp\u00e9rience fluide. NetworkManager est un composant essentiel pour les jeux multijoueurs, garantissant des communications r\u00e9seau fiables et efficaces entre les clients et le serveur.","title":"Points forts"},{"location":"overview/architecture/","text":"Architecture de l'ECS (Entity Component System) L'architecture de l'Entity Component System (ECS) mise en place dans ce projet vise \u00e0 fournir une base modulaire et flexible pour le d\u00e9veloppement du jeu R-Type. Voici une vue d'ensemble de sa structure et de ses \u00e9l\u00e9ments principaux. Vue g\u00e9n\u00e9rale L'ECS est compos\u00e9 de trois \u00e9l\u00e9ments principaux : Entity (Entit\u00e9s) : Repr\u00e9sentent les objets du jeu. Component (Composants) : Fournissent les donn\u00e9es associ\u00e9es \u00e0 une entit\u00e9. System (Syst\u00e8mes) : Contiennent la logique qui manipule les composants des entit\u00e9s. Cette architecture permet une forte d\u00e9couplage entre les donn\u00e9es et la logique, ce qui rend le syst\u00e8me facilement extensible et maintenable. Organisation du projet Voici la structure du dossier ECS : client/ecs/ \u251c\u2500\u2500 Entity.cpp \u251c\u2500\u2500 Entity.hpp \u251c\u2500\u2500 EntityManager.cpp \u251c\u2500\u2500 EntityManager.hpp \u251c\u2500\u2500 NetworkManager.cpp \u251c\u2500\u2500 NetworkManager.hpp \u251c\u2500\u2500 component \u2502 \u251c\u2500\u2500 AComponent.hpp \u2502 \u251c\u2500\u2500 BulletIdComponent.hpp \u2502 \u251c\u2500\u2500 EnnemyIdComponent.hpp \u2502 \u251c\u2500\u2500 HealthComponent.hpp \u2502 \u251c\u2500\u2500 InputComponent.hpp \u2502 \u251c\u2500\u2500 NetworkComponent.hpp \u2502 \u251c\u2500\u2500 PositionComponent.hpp \u2502 \u251c\u2500\u2500 RenderComponent.hpp \u2502 \u251c\u2500\u2500 SpriteComponent.hpp \u2502 \u251c\u2500\u2500 UsernameComponent.hpp \u2502 \u251c\u2500\u2500 VelocityComponent.hpp \u2502 \u251c\u2500\u2500 EventHandlerComponent.hpp \u2502 \u251c\u2500\u2500 HoverComponent.hpp \u2502 \u251c\u2500\u2500 ParallaxComponent.hpp \u2502 \u251c\u2500\u2500 RectangleShapeComponent.hpp \u2502 \u251c\u2500\u2500 SelectionComponent.hpp \u2502 \u251c\u2500\u2500 SoundComponent.hpp \u2502 \u2514\u2500\u2500 TextComponent.hpp \u251c\u2500\u2500 entity \u2502 \u251c\u2500\u2500 AllyEntity.cpp \u2502 \u251c\u2500\u2500 AllyEntity.hpp \u2502 \u251c\u2500\u2500 ButtonEntity.cpp \u2502 \u251c\u2500\u2500 ButtonEntity.hpp \u2502 \u251c\u2500\u2500 BydosEntity.cpp \u2502 \u251c\u2500\u2500 BydosEntity.hpp \u2502 \u251c\u2500\u2500 MenuEntity.cpp \u2502 \u251c\u2500\u2500 MenuEntity.hpp \u2502 \u251c\u2500\u2500 PlayerEntity.cpp \u2502 \u251c\u2500\u2500 PlayerEntity.hpp \u2502 \u251c\u2500\u2500 TextFieldEntity.cpp \u2502 \u2514\u2500\u2500 TextFieldEntity.hpp \u2514\u2500\u2500 system \u251c\u2500\u2500 EventHandlingSystem.cpp \u251c\u2500\u2500 EventHandlingSystem.hpp \u251c\u2500\u2500 HoverSystem.cpp \u251c\u2500\u2500 HoverSystem.hpp \u251c\u2500\u2500 InputSystem.cpp \u251c\u2500\u2500 InputSystem.hpp \u251c\u2500\u2500 MessageSystem.cpp \u251c\u2500\u2500 MessageSystem.hpp \u251c\u2500\u2500 MovementSystem.cpp \u251c\u2500\u2500 MovementSystem.hpp \u251c\u2500\u2500 ParallaxSystem.cpp \u251c\u2500\u2500 ParallaxSystem.hpp \u251c\u2500\u2500 RenderSystem.cpp \u251c\u2500\u2500 RenderSystem.hpp \u251c\u2500\u2500 SelectionSystem.cpp \u251c\u2500\u2500 SelectionSystem.hpp \u251c\u2500\u2500 SoundSystem.cpp \u2514\u2500\u2500 SoundSystem.hpp Entit\u00e9s et gestion Les entit\u00e9s sont g\u00e9r\u00e9es par la classe EntityManager . Chaque entit\u00e9 poss\u00e8de un identifiant unique (ID) qui permet de les suivre et de les manipuler dans les diff\u00e9rents syst\u00e8mes. Parmi les entit\u00e9s notables : AllyEntity : Repr\u00e9sente les alli\u00e9s du joueur. ButtonEntity : G\u00e8re les boutons interactifs des interfaces utilisateur. BydosEntity : Repr\u00e9sente les ennemis principaux. MenuEntity : Construit et g\u00e8re les menus du jeu. PlayerEntity : Repr\u00e9sente le joueur. TextFieldEntity : G\u00e8re les champs de texte interactifs. Composants Les composants sont des structures de donn\u00e9es pures, sans logique, qui d\u00e9crivent les caract\u00e9ristiques des entit\u00e9s. Ils sont organis\u00e9s dans le dossier component et incluent des \u00e9l\u00e9ments tels que : PositionComponent : G\u00e8re la position spatiale d'une entit\u00e9. HealthComponent : Suivi des points de vie. RenderComponent : Gestion de l'affichage. HoverComponent : Change l'apparence d'une entit\u00e9 lorsqu'elle est survol\u00e9e. SelectionComponent : Indique si une entit\u00e9 est s\u00e9lectionn\u00e9e. SoundComponent : G\u00e8re les effets sonores associ\u00e9s \u00e0 une entit\u00e9. Syst\u00e8mes Les syst\u00e8mes impl\u00e9mentent la logique du jeu en interagissant avec les composants. Ils incluent des syst\u00e8mes tels que : InputSystem : G\u00e8re les entr\u00e9es utilisateur. MovementSystem : Met \u00e0 jour les positions des entit\u00e9s en fonction des vitesses. RenderSystem : Dessine les entit\u00e9s \u00e0 l'\u00e9cran. HoverSystem : Modifie l'apparence des entit\u00e9s survol\u00e9es. SelectionSystem : G\u00e8re la s\u00e9lection des entit\u00e9s interactives. SoundSystem : G\u00e8re les effets sonores des entit\u00e9s. ParallaxSystem : Cr\u00e9e des effets de d\u00e9filement parallaxe. EventHandlingSystem : G\u00e8re les interactions bas\u00e9es sur des \u00e9v\u00e9nements utilisateur. Gestion r\u00e9seau La classe NetworkManager g\u00e8re les communications entre le client et le serveur, permettant de synchroniser l'\u00e9tat des entit\u00e9s \u00e0 travers le r\u00e9seau. Points forts de l'architecture Flexibilit\u00e9 : Facile \u00e0 \u00e9tendre avec de nouveaux composants ou syst\u00e8mes. Modularit\u00e9 : D\u00e9couplage des donn\u00e9es et de la logique. Performance : Appropri\u00e9 pour un traitement efficace en boucle de jeu.","title":"Architecture"},{"location":"overview/architecture/#architecture-de-lecs-entity-component-system","text":"L'architecture de l'Entity Component System (ECS) mise en place dans ce projet vise \u00e0 fournir une base modulaire et flexible pour le d\u00e9veloppement du jeu R-Type. Voici une vue d'ensemble de sa structure et de ses \u00e9l\u00e9ments principaux.","title":"Architecture de l'ECS (Entity Component System)"},{"location":"overview/architecture/#vue-generale","text":"L'ECS est compos\u00e9 de trois \u00e9l\u00e9ments principaux : Entity (Entit\u00e9s) : Repr\u00e9sentent les objets du jeu. Component (Composants) : Fournissent les donn\u00e9es associ\u00e9es \u00e0 une entit\u00e9. System (Syst\u00e8mes) : Contiennent la logique qui manipule les composants des entit\u00e9s. Cette architecture permet une forte d\u00e9couplage entre les donn\u00e9es et la logique, ce qui rend le syst\u00e8me facilement extensible et maintenable.","title":"Vue g\u00e9n\u00e9rale"},{"location":"overview/architecture/#organisation-du-projet","text":"Voici la structure du dossier ECS : client/ecs/ \u251c\u2500\u2500 Entity.cpp \u251c\u2500\u2500 Entity.hpp \u251c\u2500\u2500 EntityManager.cpp \u251c\u2500\u2500 EntityManager.hpp \u251c\u2500\u2500 NetworkManager.cpp \u251c\u2500\u2500 NetworkManager.hpp \u251c\u2500\u2500 component \u2502 \u251c\u2500\u2500 AComponent.hpp \u2502 \u251c\u2500\u2500 BulletIdComponent.hpp \u2502 \u251c\u2500\u2500 EnnemyIdComponent.hpp \u2502 \u251c\u2500\u2500 HealthComponent.hpp \u2502 \u251c\u2500\u2500 InputComponent.hpp \u2502 \u251c\u2500\u2500 NetworkComponent.hpp \u2502 \u251c\u2500\u2500 PositionComponent.hpp \u2502 \u251c\u2500\u2500 RenderComponent.hpp \u2502 \u251c\u2500\u2500 SpriteComponent.hpp \u2502 \u251c\u2500\u2500 UsernameComponent.hpp \u2502 \u251c\u2500\u2500 VelocityComponent.hpp \u2502 \u251c\u2500\u2500 EventHandlerComponent.hpp \u2502 \u251c\u2500\u2500 HoverComponent.hpp \u2502 \u251c\u2500\u2500 ParallaxComponent.hpp \u2502 \u251c\u2500\u2500 RectangleShapeComponent.hpp \u2502 \u251c\u2500\u2500 SelectionComponent.hpp \u2502 \u251c\u2500\u2500 SoundComponent.hpp \u2502 \u2514\u2500\u2500 TextComponent.hpp \u251c\u2500\u2500 entity \u2502 \u251c\u2500\u2500 AllyEntity.cpp \u2502 \u251c\u2500\u2500 AllyEntity.hpp \u2502 \u251c\u2500\u2500 ButtonEntity.cpp \u2502 \u251c\u2500\u2500 ButtonEntity.hpp \u2502 \u251c\u2500\u2500 BydosEntity.cpp \u2502 \u251c\u2500\u2500 BydosEntity.hpp \u2502 \u251c\u2500\u2500 MenuEntity.cpp \u2502 \u251c\u2500\u2500 MenuEntity.hpp \u2502 \u251c\u2500\u2500 PlayerEntity.cpp \u2502 \u251c\u2500\u2500 PlayerEntity.hpp \u2502 \u251c\u2500\u2500 TextFieldEntity.cpp \u2502 \u2514\u2500\u2500 TextFieldEntity.hpp \u2514\u2500\u2500 system \u251c\u2500\u2500 EventHandlingSystem.cpp \u251c\u2500\u2500 EventHandlingSystem.hpp \u251c\u2500\u2500 HoverSystem.cpp \u251c\u2500\u2500 HoverSystem.hpp \u251c\u2500\u2500 InputSystem.cpp \u251c\u2500\u2500 InputSystem.hpp \u251c\u2500\u2500 MessageSystem.cpp \u251c\u2500\u2500 MessageSystem.hpp \u251c\u2500\u2500 MovementSystem.cpp \u251c\u2500\u2500 MovementSystem.hpp \u251c\u2500\u2500 ParallaxSystem.cpp \u251c\u2500\u2500 ParallaxSystem.hpp \u251c\u2500\u2500 RenderSystem.cpp \u251c\u2500\u2500 RenderSystem.hpp \u251c\u2500\u2500 SelectionSystem.cpp \u251c\u2500\u2500 SelectionSystem.hpp \u251c\u2500\u2500 SoundSystem.cpp \u2514\u2500\u2500 SoundSystem.hpp","title":"Organisation du projet"},{"location":"overview/architecture/#entites-et-gestion","text":"Les entit\u00e9s sont g\u00e9r\u00e9es par la classe EntityManager . Chaque entit\u00e9 poss\u00e8de un identifiant unique (ID) qui permet de les suivre et de les manipuler dans les diff\u00e9rents syst\u00e8mes. Parmi les entit\u00e9s notables : AllyEntity : Repr\u00e9sente les alli\u00e9s du joueur. ButtonEntity : G\u00e8re les boutons interactifs des interfaces utilisateur. BydosEntity : Repr\u00e9sente les ennemis principaux. MenuEntity : Construit et g\u00e8re les menus du jeu. PlayerEntity : Repr\u00e9sente le joueur. TextFieldEntity : G\u00e8re les champs de texte interactifs.","title":"Entit\u00e9s et gestion"},{"location":"overview/architecture/#composants","text":"Les composants sont des structures de donn\u00e9es pures, sans logique, qui d\u00e9crivent les caract\u00e9ristiques des entit\u00e9s. Ils sont organis\u00e9s dans le dossier component et incluent des \u00e9l\u00e9ments tels que : PositionComponent : G\u00e8re la position spatiale d'une entit\u00e9. HealthComponent : Suivi des points de vie. RenderComponent : Gestion de l'affichage. HoverComponent : Change l'apparence d'une entit\u00e9 lorsqu'elle est survol\u00e9e. SelectionComponent : Indique si une entit\u00e9 est s\u00e9lectionn\u00e9e. SoundComponent : G\u00e8re les effets sonores associ\u00e9s \u00e0 une entit\u00e9.","title":"Composants"},{"location":"overview/architecture/#systemes","text":"Les syst\u00e8mes impl\u00e9mentent la logique du jeu en interagissant avec les composants. Ils incluent des syst\u00e8mes tels que : InputSystem : G\u00e8re les entr\u00e9es utilisateur. MovementSystem : Met \u00e0 jour les positions des entit\u00e9s en fonction des vitesses. RenderSystem : Dessine les entit\u00e9s \u00e0 l'\u00e9cran. HoverSystem : Modifie l'apparence des entit\u00e9s survol\u00e9es. SelectionSystem : G\u00e8re la s\u00e9lection des entit\u00e9s interactives. SoundSystem : G\u00e8re les effets sonores des entit\u00e9s. ParallaxSystem : Cr\u00e9e des effets de d\u00e9filement parallaxe. EventHandlingSystem : G\u00e8re les interactions bas\u00e9es sur des \u00e9v\u00e9nements utilisateur.","title":"Syst\u00e8mes"},{"location":"overview/architecture/#gestion-reseau","text":"La classe NetworkManager g\u00e8re les communications entre le client et le serveur, permettant de synchroniser l'\u00e9tat des entit\u00e9s \u00e0 travers le r\u00e9seau.","title":"Gestion r\u00e9seau"},{"location":"overview/architecture/#points-forts-de-larchitecture","text":"Flexibilit\u00e9 : Facile \u00e0 \u00e9tendre avec de nouveaux composants ou syst\u00e8mes. Modularit\u00e9 : D\u00e9couplage des donn\u00e9es et de la logique. Performance : Appropri\u00e9 pour un traitement efficace en boucle de jeu.","title":"Points forts de l'architecture"},{"location":"overview/introduction/","text":"Introduction Bienvenue dans la documentation de l'architecture ECS (Entity Component System) du projet R-Type. Cette documentation a pour but de fournir une vue claire et d\u00e9taill\u00e9e de la structure et du fonctionnement de l'ECS, une partie centrale de notre moteur de jeu. Qu'est-ce qu'un ECS ? L'Entity Component System est un mod\u00e8le architectural con\u00e7u pour fournir une approche modulaire et flexible \u00e0 la cr\u00e9ation de jeux. Il repose sur trois piliers principaux : Entit\u00e9s : Des conteneurs d'identit\u00e9, sans logique ou donn\u00e9es. Composants : Des structures de donn\u00e9es attach\u00e9es aux entit\u00e9s pour d\u00e9crire leurs caract\u00e9ristiques. Syst\u00e8mes : Des modules logiques qui op\u00e8rent sur des ensembles d'entit\u00e9s ayant des composants pertinents. Cette approche s'\u00e9loigne des mod\u00e8les traditionnels orient\u00e9s objet en d\u00e9coupant clairement les donn\u00e9es et la logique, ce qui facilite l'\u00e9volution du code et la r\u00e9utilisation des composants. Objectifs de l'ECS dans ce projet Notre ECS est con\u00e7u pour r\u00e9pondre aux besoins sp\u00e9cifiques du jeu R-Type, notamment : Flexibilit\u00e9 : Faciliter l'ajout de nouvelles fonctionnalit\u00e9s. Performance : Optimiser les traitements gr\u00e2ce \u00e0 une architecture orient\u00e9e sur les donn\u00e9es. Modularit\u00e9 : Permettre une s\u00e9paration claire des responsabilit\u00e9s entre les diff\u00e9rents syst\u00e8mes. Contenu de cette documentation Voici les sections principales que vous trouverez dans cette documentation : Overview : Une vue d'ensemble de l'architecture et des concepts fondamentaux. Components : D\u00e9tails des diff\u00e9rents composants impl\u00e9ment\u00e9s. Systems : Explication des syst\u00e8mes et de leurs interactions avec les composants. Managers : Pr\u00e9sentation des gestionnaires principaux, comme l'EntityManager et le NetworkManager. Pourquoi cette documentation est importante Une documentation bien structur\u00e9e est essentielle pour : Permettre aux nouveaux d\u00e9veloppeurs de se familiariser rapidement avec le projet. Assurer une maintenance efficace du code. Faciliter les \u00e9volutions futures en fournissant une vue d'ensemble claire des interactions entre les diff\u00e9rents \u00e9l\u00e9ments.","title":"Introduction"},{"location":"overview/introduction/#introduction","text":"Bienvenue dans la documentation de l'architecture ECS (Entity Component System) du projet R-Type. Cette documentation a pour but de fournir une vue claire et d\u00e9taill\u00e9e de la structure et du fonctionnement de l'ECS, une partie centrale de notre moteur de jeu.","title":"Introduction"},{"location":"overview/introduction/#quest-ce-quun-ecs","text":"L'Entity Component System est un mod\u00e8le architectural con\u00e7u pour fournir une approche modulaire et flexible \u00e0 la cr\u00e9ation de jeux. Il repose sur trois piliers principaux : Entit\u00e9s : Des conteneurs d'identit\u00e9, sans logique ou donn\u00e9es. Composants : Des structures de donn\u00e9es attach\u00e9es aux entit\u00e9s pour d\u00e9crire leurs caract\u00e9ristiques. Syst\u00e8mes : Des modules logiques qui op\u00e8rent sur des ensembles d'entit\u00e9s ayant des composants pertinents. Cette approche s'\u00e9loigne des mod\u00e8les traditionnels orient\u00e9s objet en d\u00e9coupant clairement les donn\u00e9es et la logique, ce qui facilite l'\u00e9volution du code et la r\u00e9utilisation des composants.","title":"Qu'est-ce qu'un ECS ?"},{"location":"overview/introduction/#objectifs-de-lecs-dans-ce-projet","text":"Notre ECS est con\u00e7u pour r\u00e9pondre aux besoins sp\u00e9cifiques du jeu R-Type, notamment : Flexibilit\u00e9 : Faciliter l'ajout de nouvelles fonctionnalit\u00e9s. Performance : Optimiser les traitements gr\u00e2ce \u00e0 une architecture orient\u00e9e sur les donn\u00e9es. Modularit\u00e9 : Permettre une s\u00e9paration claire des responsabilit\u00e9s entre les diff\u00e9rents syst\u00e8mes.","title":"Objectifs de l'ECS dans ce projet"},{"location":"overview/introduction/#contenu-de-cette-documentation","text":"Voici les sections principales que vous trouverez dans cette documentation : Overview : Une vue d'ensemble de l'architecture et des concepts fondamentaux. Components : D\u00e9tails des diff\u00e9rents composants impl\u00e9ment\u00e9s. Systems : Explication des syst\u00e8mes et de leurs interactions avec les composants. Managers : Pr\u00e9sentation des gestionnaires principaux, comme l'EntityManager et le NetworkManager.","title":"Contenu de cette documentation"},{"location":"overview/introduction/#pourquoi-cette-documentation-est-importante","text":"Une documentation bien structur\u00e9e est essentielle pour : Permettre aux nouveaux d\u00e9veloppeurs de se familiariser rapidement avec le projet. Assurer une maintenance efficace du code. Faciliter les \u00e9volutions futures en fournissant une vue d'ensemble claire des interactions entre les diff\u00e9rents \u00e9l\u00e9ments.","title":"Pourquoi cette documentation est importante"},{"location":"systems/event_handling_system/","text":"EventHandlingSystem Introduction EventHandlingSystem est un syst\u00e8me con\u00e7u pour g\u00e9rer les interactions utilisateur en \u00e9coutant et en traitant les \u00e9v\u00e9nements SFML. Il ex\u00e9cute les callbacks associ\u00e9s aux entit\u00e9s disposant de composants EventHandlerComponent . R\u00f4le dans l'ECS EventHandlingSystem est utilis\u00e9 pour : \u00c9couter les \u00e9v\u00e9nements utilisateur, tels que les clics de souris ou les pressions de touches. Ex\u00e9cuter les fonctions de callback d\u00e9finies dans les composants EventHandlerComponent . Assurer une gestion fluide des interactions entre les entit\u00e9s et l'utilisateur. Fonctionnalit\u00e9s principales M\u00e9thode update La m\u00e9thode update parcourt toutes les entit\u00e9s et ex\u00e9cute les callbacks associ\u00e9s aux \u00e9v\u00e9nements d\u00e9clench\u00e9s. Code extrait de EventHandlingSystem.cpp : void EventHandlingSystem::update(EntityManager &entityManager, const sf::Event &event) { for (size_t i = 0; i < entityManager.entities.size(); i++) { auto &entity = entityManager.entities[i]; auto *eventHandlerComponent = entity->getComponent<EventHandlerComponent>(); if (eventHandlerComponent) { if (eventHandlerComponent->callbacks.find(event.type) != eventHandlerComponent->callbacks.end()) try { eventHandlerComponent->callbacks.at(event.type)(event); } catch (std::exception &e) { std::cerr << e.what() << std::endl; } } } entityManager.destroyMarkedEntities(); } Interactions Avec EventHandlerComponent : Ex\u00e9cute les callbacks d\u00e9finis dans ce composant en fonction des \u00e9v\u00e9nements re\u00e7us. Avec EntityManager : Parcourt les entit\u00e9s et applique les changements n\u00e9cessaires. Exemples d'Utilisation Initialisation et utilisation : cpp sf::Event event; while (window.pollEvent(event)) { eventHandlingSystem.update(entityManager, event); } Ajout d'un callback \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<EventHandlerComponent>(sf::Event::MouseButtonPressed, [](const sf::Event &event) { std::cout << \"Bouton cliqu\u00e9 !\" << std::endl; }); Fonctionnalit\u00e9s suppl\u00e9mentaires Gestion des exceptions : Capture les erreurs lors de l'ex\u00e9cution des callbacks pour \u00e9viter les interruptions. Destruction des entit\u00e9s : Supprime les entit\u00e9s marqu\u00e9es apr\u00e8s la gestion des \u00e9v\u00e9nements. EventHandlingSystem est essentiel pour impl\u00e9menter des interactions dynamiques et r\u00e9actives dans le jeu, en connectant les \u00e9v\u00e9nements utilisateur aux actions sp\u00e9cifiques des entit\u00e9s.","title":"EventHandlingSystem"},{"location":"systems/event_handling_system/#eventhandlingsystem","text":"","title":"EventHandlingSystem"},{"location":"systems/event_handling_system/#introduction","text":"EventHandlingSystem est un syst\u00e8me con\u00e7u pour g\u00e9rer les interactions utilisateur en \u00e9coutant et en traitant les \u00e9v\u00e9nements SFML. Il ex\u00e9cute les callbacks associ\u00e9s aux entit\u00e9s disposant de composants EventHandlerComponent .","title":"Introduction"},{"location":"systems/event_handling_system/#role-dans-lecs","text":"EventHandlingSystem est utilis\u00e9 pour : \u00c9couter les \u00e9v\u00e9nements utilisateur, tels que les clics de souris ou les pressions de touches. Ex\u00e9cuter les fonctions de callback d\u00e9finies dans les composants EventHandlerComponent . Assurer une gestion fluide des interactions entre les entit\u00e9s et l'utilisateur.","title":"R\u00f4le dans l'ECS"},{"location":"systems/event_handling_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/event_handling_system/#methode-update","text":"La m\u00e9thode update parcourt toutes les entit\u00e9s et ex\u00e9cute les callbacks associ\u00e9s aux \u00e9v\u00e9nements d\u00e9clench\u00e9s.","title":"M\u00e9thode update"},{"location":"systems/event_handling_system/#code-extrait-de-eventhandlingsystemcpp","text":"void EventHandlingSystem::update(EntityManager &entityManager, const sf::Event &event) { for (size_t i = 0; i < entityManager.entities.size(); i++) { auto &entity = entityManager.entities[i]; auto *eventHandlerComponent = entity->getComponent<EventHandlerComponent>(); if (eventHandlerComponent) { if (eventHandlerComponent->callbacks.find(event.type) != eventHandlerComponent->callbacks.end()) try { eventHandlerComponent->callbacks.at(event.type)(event); } catch (std::exception &e) { std::cerr << e.what() << std::endl; } } } entityManager.destroyMarkedEntities(); }","title":"Code extrait de EventHandlingSystem.cpp :"},{"location":"systems/event_handling_system/#interactions","text":"Avec EventHandlerComponent : Ex\u00e9cute les callbacks d\u00e9finis dans ce composant en fonction des \u00e9v\u00e9nements re\u00e7us. Avec EntityManager : Parcourt les entit\u00e9s et applique les changements n\u00e9cessaires.","title":"Interactions"},{"location":"systems/event_handling_system/#exemples-dutilisation","text":"Initialisation et utilisation : cpp sf::Event event; while (window.pollEvent(event)) { eventHandlingSystem.update(entityManager, event); } Ajout d'un callback \u00e0 une entit\u00e9 : cpp Entity &button = entityManager.createEntity(); button.addComponent<EventHandlerComponent>(sf::Event::MouseButtonPressed, [](const sf::Event &event) { std::cout << \"Bouton cliqu\u00e9 !\" << std::endl; });","title":"Exemples d'Utilisation"},{"location":"systems/event_handling_system/#fonctionnalites-supplementaires","text":"Gestion des exceptions : Capture les erreurs lors de l'ex\u00e9cution des callbacks pour \u00e9viter les interruptions. Destruction des entit\u00e9s : Supprime les entit\u00e9s marqu\u00e9es apr\u00e8s la gestion des \u00e9v\u00e9nements. EventHandlingSystem est essentiel pour impl\u00e9menter des interactions dynamiques et r\u00e9actives dans le jeu, en connectant les \u00e9v\u00e9nements utilisateur aux actions sp\u00e9cifiques des entit\u00e9s.","title":"Fonctionnalit\u00e9s suppl\u00e9mentaires"},{"location":"systems/hover_system/","text":"HoverSystem Introduction HoverSystem g\u00e8re les interactions visuelles li\u00e9es au survol de la souris sur les entit\u00e9s. Il modifie l'apparence des entit\u00e9s ayant un composant HoverComponent en fonction de la position actuelle de la souris. R\u00f4le dans l'ECS HoverSystem est utilis\u00e9 pour : D\u00e9tecter si la souris survole une entit\u00e9. Modifier l'apparence visuelle des entit\u00e9s pour fournir un retour utilisateur. Faciliter les interactions intuitives avec des entit\u00e9s interactives comme des boutons ou des \u00e9l\u00e9ments graphiques. Fonctionnalit\u00e9s principales M\u00e9thode update La m\u00e9thode update parcourt toutes les entit\u00e9s et applique les couleurs d\u00e9finies dans le HoverComponent en fonction de la position de la souris. Code extrait de HoverSystem.cpp : void HoverSystem::update(EntityManager &entityManager, float x, float y) { for (auto &i : entityManager.entities) { auto *hoverComponent = i->getComponent<HoverComponent>(); auto *spriteComponent = i->getComponent<SpriteComponent>(); auto *rectangleShapeComponent = i->getComponent<RectangleShapeComponent>(); if (hoverComponent && spriteComponent) { if (spriteComponent->sprite.getGlobalBounds().contains(x, y)) { spriteComponent->sprite.setColor(hoverComponent->hoverColor); } else { spriteComponent->sprite.setColor(hoverComponent->defaultColor); } } if (hoverComponent && rectangleShapeComponent) { if (rectangleShapeComponent->shape.getGlobalBounds().contains(x, y)) { rectangleShapeComponent->shape.setFillColor(hoverComponent->hoverColor); } else { rectangleShapeComponent->shape.setFillColor(hoverComponent->defaultColor); } } } } Interactions Avec HoverComponent : Utilise les couleurs d\u00e9finies pour le survol et l'\u00e9tat par d\u00e9faut. Avec SpriteComponent : Change la couleur des sprites en fonction de la position de la souris. Avec RectangleShapeComponent : Modifie la couleur des formes rectangulaires selon le survol. Exemples d'Utilisation Initialisation et utilisation : cpp sf::Vector2i mousePosition = sf::Mouse::getPosition(window); hoverSystem.update(entityManager, static_cast<float>(mousePosition.x), static_cast<float>(mousePosition.y)); Ajout d'un HoverComponent : cpp Entity &button = entityManager.createEntity(); button.addComponent<HoverComponent>(sf::Color::White, sf::Color::Blue); Fonctionnalit\u00e9s suppl\u00e9mentaires Retour visuel imm\u00e9diat : Am\u00e9liore l'exp\u00e9rience utilisateur en fournissant un retour intuitif lors du survol. Gestion flexible : Compatible avec diff\u00e9rents types de composants visuels (sprites, formes). HoverSystem est un syst\u00e8me essentiel pour les interfaces utilisateur et les interactions graphiques, offrant une exp\u00e9rience fluide et immersive.","title":"HoverSystem"},{"location":"systems/hover_system/#hoversystem","text":"","title":"HoverSystem"},{"location":"systems/hover_system/#introduction","text":"HoverSystem g\u00e8re les interactions visuelles li\u00e9es au survol de la souris sur les entit\u00e9s. Il modifie l'apparence des entit\u00e9s ayant un composant HoverComponent en fonction de la position actuelle de la souris.","title":"Introduction"},{"location":"systems/hover_system/#role-dans-lecs","text":"HoverSystem est utilis\u00e9 pour : D\u00e9tecter si la souris survole une entit\u00e9. Modifier l'apparence visuelle des entit\u00e9s pour fournir un retour utilisateur. Faciliter les interactions intuitives avec des entit\u00e9s interactives comme des boutons ou des \u00e9l\u00e9ments graphiques.","title":"R\u00f4le dans l'ECS"},{"location":"systems/hover_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/hover_system/#methode-update","text":"La m\u00e9thode update parcourt toutes les entit\u00e9s et applique les couleurs d\u00e9finies dans le HoverComponent en fonction de la position de la souris.","title":"M\u00e9thode update"},{"location":"systems/hover_system/#code-extrait-de-hoversystemcpp","text":"void HoverSystem::update(EntityManager &entityManager, float x, float y) { for (auto &i : entityManager.entities) { auto *hoverComponent = i->getComponent<HoverComponent>(); auto *spriteComponent = i->getComponent<SpriteComponent>(); auto *rectangleShapeComponent = i->getComponent<RectangleShapeComponent>(); if (hoverComponent && spriteComponent) { if (spriteComponent->sprite.getGlobalBounds().contains(x, y)) { spriteComponent->sprite.setColor(hoverComponent->hoverColor); } else { spriteComponent->sprite.setColor(hoverComponent->defaultColor); } } if (hoverComponent && rectangleShapeComponent) { if (rectangleShapeComponent->shape.getGlobalBounds().contains(x, y)) { rectangleShapeComponent->shape.setFillColor(hoverComponent->hoverColor); } else { rectangleShapeComponent->shape.setFillColor(hoverComponent->defaultColor); } } } }","title":"Code extrait de HoverSystem.cpp :"},{"location":"systems/hover_system/#interactions","text":"Avec HoverComponent : Utilise les couleurs d\u00e9finies pour le survol et l'\u00e9tat par d\u00e9faut. Avec SpriteComponent : Change la couleur des sprites en fonction de la position de la souris. Avec RectangleShapeComponent : Modifie la couleur des formes rectangulaires selon le survol.","title":"Interactions"},{"location":"systems/hover_system/#exemples-dutilisation","text":"Initialisation et utilisation : cpp sf::Vector2i mousePosition = sf::Mouse::getPosition(window); hoverSystem.update(entityManager, static_cast<float>(mousePosition.x), static_cast<float>(mousePosition.y)); Ajout d'un HoverComponent : cpp Entity &button = entityManager.createEntity(); button.addComponent<HoverComponent>(sf::Color::White, sf::Color::Blue);","title":"Exemples d'Utilisation"},{"location":"systems/hover_system/#fonctionnalites-supplementaires","text":"Retour visuel imm\u00e9diat : Am\u00e9liore l'exp\u00e9rience utilisateur en fournissant un retour intuitif lors du survol. Gestion flexible : Compatible avec diff\u00e9rents types de composants visuels (sprites, formes). HoverSystem est un syst\u00e8me essentiel pour les interfaces utilisateur et les interactions graphiques, offrant une exp\u00e9rience fluide et immersive.","title":"Fonctionnalit\u00e9s suppl\u00e9mentaires"},{"location":"systems/input_system/","text":"InputSystem Introduction Le syst\u00e8me InputSystem est responsable de la gestion des entr\u00e9es utilisateur et de leur traduction en actions sur les entit\u00e9s correspondantes. Il d\u00e9tecte les touches press\u00e9es et met \u00e0 jour les composants d'entr\u00e9e des entit\u00e9s concern\u00e9es. R\u00f4le dans l'ECS InputSystem a pour r\u00f4le de : Capturer les entr\u00e9es utilisateur en temps r\u00e9el. Mettre \u00e0 jour les \u00e9tats des composants InputComponent pour refl\u00e9ter les actions actuelles. Fournir une interface permettant aux autres syst\u00e8mes de r\u00e9agir aux actions utilisateur. Fonctionnalit\u00e9s principales M\u00e9thode update Cette m\u00e9thode parcourt toutes les entit\u00e9s qui poss\u00e8dent un InputComponent et met \u00e0 jour leurs attributs en fonction des touches press\u00e9es. Exemple de code void InputSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *input = entity->getComponent<InputComponent>(); if (input) { input->moveLeft = sf::Keyboard::isKeyPressed(sf::Keyboard::Left); input->moveRight = sf::Keyboard::isKeyPressed(sf::Keyboard::Right); input->moveUp = sf::Keyboard::isKeyPressed(sf::Keyboard::Up); input->moveDown = sf::Keyboard::isKeyPressed(sf::Keyboard::Down); input->spaceBar = sf::Keyboard::isKeyPressed(sf::Keyboard::Space); } } } Gestion des interactions Les entr\u00e9es captur\u00e9es par ce syst\u00e8me sont ensuite utilis\u00e9es par d'autres syst\u00e8mes tels que MovementSystem ou RenderSystem pour influencer les actions du jeu. Exemples d'Utilisation Initialisation et appel : cpp InputSystem inputSystem; inputSystem.update(entityManager); R\u00e9agir aux entr\u00e9es utilisateur : Les composants mis \u00e0 jour par ce syst\u00e8me sont ensuite utilis\u00e9s pour d\u00e9placer les entit\u00e9s ou d\u00e9clencher des actions sp\u00e9cifiques. Interactions Avec InputComponent : Met \u00e0 jour les attributs de ce composant en fonction des entr\u00e9es utilisateur. Avec MovementSystem : Fournit les donn\u00e9es n\u00e9cessaires pour d\u00e9placer les entit\u00e9s en fonction des commandes utilisateur. Avec NetworkManager : Synchronise les commandes utilisateur avec le serveur dans un environnement multijoueur. Le syst\u00e8me InputSystem est un \u00e9l\u00e9ment cl\u00e9 pour connecter les actions des joueurs aux entit\u00e9s du jeu, garantissant une interaction fluide et r\u00e9active.","title":"InputSystem"},{"location":"systems/input_system/#inputsystem","text":"","title":"InputSystem"},{"location":"systems/input_system/#introduction","text":"Le syst\u00e8me InputSystem est responsable de la gestion des entr\u00e9es utilisateur et de leur traduction en actions sur les entit\u00e9s correspondantes. Il d\u00e9tecte les touches press\u00e9es et met \u00e0 jour les composants d'entr\u00e9e des entit\u00e9s concern\u00e9es.","title":"Introduction"},{"location":"systems/input_system/#role-dans-lecs","text":"InputSystem a pour r\u00f4le de : Capturer les entr\u00e9es utilisateur en temps r\u00e9el. Mettre \u00e0 jour les \u00e9tats des composants InputComponent pour refl\u00e9ter les actions actuelles. Fournir une interface permettant aux autres syst\u00e8mes de r\u00e9agir aux actions utilisateur.","title":"R\u00f4le dans l'ECS"},{"location":"systems/input_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/input_system/#methode-update","text":"Cette m\u00e9thode parcourt toutes les entit\u00e9s qui poss\u00e8dent un InputComponent et met \u00e0 jour leurs attributs en fonction des touches press\u00e9es.","title":"M\u00e9thode update"},{"location":"systems/input_system/#exemple-de-code","text":"void InputSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *input = entity->getComponent<InputComponent>(); if (input) { input->moveLeft = sf::Keyboard::isKeyPressed(sf::Keyboard::Left); input->moveRight = sf::Keyboard::isKeyPressed(sf::Keyboard::Right); input->moveUp = sf::Keyboard::isKeyPressed(sf::Keyboard::Up); input->moveDown = sf::Keyboard::isKeyPressed(sf::Keyboard::Down); input->spaceBar = sf::Keyboard::isKeyPressed(sf::Keyboard::Space); } } }","title":"Exemple de code"},{"location":"systems/input_system/#gestion-des-interactions","text":"Les entr\u00e9es captur\u00e9es par ce syst\u00e8me sont ensuite utilis\u00e9es par d'autres syst\u00e8mes tels que MovementSystem ou RenderSystem pour influencer les actions du jeu.","title":"Gestion des interactions"},{"location":"systems/input_system/#exemples-dutilisation","text":"Initialisation et appel : cpp InputSystem inputSystem; inputSystem.update(entityManager); R\u00e9agir aux entr\u00e9es utilisateur : Les composants mis \u00e0 jour par ce syst\u00e8me sont ensuite utilis\u00e9s pour d\u00e9placer les entit\u00e9s ou d\u00e9clencher des actions sp\u00e9cifiques.","title":"Exemples d'Utilisation"},{"location":"systems/input_system/#interactions","text":"Avec InputComponent : Met \u00e0 jour les attributs de ce composant en fonction des entr\u00e9es utilisateur. Avec MovementSystem : Fournit les donn\u00e9es n\u00e9cessaires pour d\u00e9placer les entit\u00e9s en fonction des commandes utilisateur. Avec NetworkManager : Synchronise les commandes utilisateur avec le serveur dans un environnement multijoueur. Le syst\u00e8me InputSystem est un \u00e9l\u00e9ment cl\u00e9 pour connecter les actions des joueurs aux entit\u00e9s du jeu, garantissant une interaction fluide et r\u00e9active.","title":"Interactions"},{"location":"systems/message_system/","text":"MessageSystem Introduction Le syst\u00e8me MessageSystem est con\u00e7u pour g\u00e9rer la communication entre le client et le serveur. Il permet de recevoir et de traiter les messages r\u00e9seau, tout en mettant \u00e0 jour les entit\u00e9s du jeu en cons\u00e9quence. R\u00f4le dans l'ECS MessageSystem est responsable de : R\u00e9cup\u00e9rer les messages re\u00e7us via le r\u00e9seau. D\u00e9coder et interpr\u00e9ter les messages pour mettre \u00e0 jour les entit\u00e9s concern\u00e9es. Envoyer les r\u00e9ponses ou les mises \u00e0 jour n\u00e9cessaires au serveur. Fonctionnalit\u00e9s principales M\u00e9thode update La m\u00e9thode update traite les messages en file d'attente, identifie leur type, et invoque les fonctions appropri\u00e9es pour mettre \u00e0 jour les entit\u00e9s. Exemple de code void MessageSystem::update(EntityManager &entityManager, NetworkManager &networkManager, std::string localUsername) { auto receivedMessages = networkManager.getReceivedMessages(); while (!receivedMessages.empty()) { auto message = receivedMessages.front(); receivedMessages.pop(); const char *ptr = message.data(); auto messageType = static_cast<MessageType>(Serializer::deserialize<uint8_t>(ptr)); switch (messageType) { case MessageType::UPDATE_CLIENTS: handleUpdateClients(entityManager, ptr, localUsername); break; case MessageType::UPDATE_BULLETS: handleUpdateBullets(entityManager, ptr); break; case MessageType::ERROR: handleError(ptr); break; case MessageType::UPDATE_ENEMIES: handleUpdateEnemies(entityManager, ptr); break; default: break; } } } M\u00e9thodes de traitement handleUpdateClients : Met \u00e0 jour les positions et les donn\u00e9es des clients. handleUpdateBullets : Ajoute ou met \u00e0 jour les projectiles dans le jeu. handleError : Affiche les messages d'erreur re\u00e7us. handleUpdateEnemies : Synchronise les donn\u00e9es des ennemis avec celles re\u00e7ues du serveur. Exemples d'Utilisation Initialisation et appel : cpp MessageSystem messageSystem; messageSystem.update(entityManager, networkManager, \"Player1\"); Traitement des erreurs : cpp void MessageSystem::handleError(const char *&ptr) { std::cerr << \"Erreur re\u00e7ue : \" << Serializer::deserializeString(ptr) << std::endl; } Interactions Avec NetworkManager : R\u00e9cup\u00e8re les messages du r\u00e9seau et envoie les r\u00e9ponses. Avec EntityManager : Met \u00e0 jour ou cr\u00e9e des entit\u00e9s en fonction des messages re\u00e7us. Avec Serializer : Utilis\u00e9 pour coder et d\u00e9coder les donn\u00e9es des messages. Le syst\u00e8me MessageSystem joue un r\u00f4le central dans la gestion des communications r\u00e9seau, garantissant une synchronisation fluide entre le client et le serveur.","title":"MessageSystem"},{"location":"systems/message_system/#messagesystem","text":"","title":"MessageSystem"},{"location":"systems/message_system/#introduction","text":"Le syst\u00e8me MessageSystem est con\u00e7u pour g\u00e9rer la communication entre le client et le serveur. Il permet de recevoir et de traiter les messages r\u00e9seau, tout en mettant \u00e0 jour les entit\u00e9s du jeu en cons\u00e9quence.","title":"Introduction"},{"location":"systems/message_system/#role-dans-lecs","text":"MessageSystem est responsable de : R\u00e9cup\u00e9rer les messages re\u00e7us via le r\u00e9seau. D\u00e9coder et interpr\u00e9ter les messages pour mettre \u00e0 jour les entit\u00e9s concern\u00e9es. Envoyer les r\u00e9ponses ou les mises \u00e0 jour n\u00e9cessaires au serveur.","title":"R\u00f4le dans l'ECS"},{"location":"systems/message_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/message_system/#methode-update","text":"La m\u00e9thode update traite les messages en file d'attente, identifie leur type, et invoque les fonctions appropri\u00e9es pour mettre \u00e0 jour les entit\u00e9s.","title":"M\u00e9thode update"},{"location":"systems/message_system/#exemple-de-code","text":"void MessageSystem::update(EntityManager &entityManager, NetworkManager &networkManager, std::string localUsername) { auto receivedMessages = networkManager.getReceivedMessages(); while (!receivedMessages.empty()) { auto message = receivedMessages.front(); receivedMessages.pop(); const char *ptr = message.data(); auto messageType = static_cast<MessageType>(Serializer::deserialize<uint8_t>(ptr)); switch (messageType) { case MessageType::UPDATE_CLIENTS: handleUpdateClients(entityManager, ptr, localUsername); break; case MessageType::UPDATE_BULLETS: handleUpdateBullets(entityManager, ptr); break; case MessageType::ERROR: handleError(ptr); break; case MessageType::UPDATE_ENEMIES: handleUpdateEnemies(entityManager, ptr); break; default: break; } } }","title":"Exemple de code"},{"location":"systems/message_system/#methodes-de-traitement","text":"handleUpdateClients : Met \u00e0 jour les positions et les donn\u00e9es des clients. handleUpdateBullets : Ajoute ou met \u00e0 jour les projectiles dans le jeu. handleError : Affiche les messages d'erreur re\u00e7us. handleUpdateEnemies : Synchronise les donn\u00e9es des ennemis avec celles re\u00e7ues du serveur.","title":"M\u00e9thodes de traitement"},{"location":"systems/message_system/#exemples-dutilisation","text":"Initialisation et appel : cpp MessageSystem messageSystem; messageSystem.update(entityManager, networkManager, \"Player1\"); Traitement des erreurs : cpp void MessageSystem::handleError(const char *&ptr) { std::cerr << \"Erreur re\u00e7ue : \" << Serializer::deserializeString(ptr) << std::endl; }","title":"Exemples d'Utilisation"},{"location":"systems/message_system/#interactions","text":"Avec NetworkManager : R\u00e9cup\u00e8re les messages du r\u00e9seau et envoie les r\u00e9ponses. Avec EntityManager : Met \u00e0 jour ou cr\u00e9e des entit\u00e9s en fonction des messages re\u00e7us. Avec Serializer : Utilis\u00e9 pour coder et d\u00e9coder les donn\u00e9es des messages. Le syst\u00e8me MessageSystem joue un r\u00f4le central dans la gestion des communications r\u00e9seau, garantissant une synchronisation fluide entre le client et le serveur.","title":"Interactions"},{"location":"systems/movement_system/","text":"MovementSystem Introduction Le syst\u00e8me MovementSystem est responsable de la mise \u00e0 jour des positions des entit\u00e9s en fonction de leur vitesse et des entr\u00e9es utilisateur. Il joue un r\u00f4le cl\u00e9 dans le d\u00e9placement des entit\u00e9s dans le jeu. R\u00f4le dans l'ECS MovementSystem a pour r\u00f4le de : Calculer les nouvelles positions des entit\u00e9s en fonction de leur VelocityComponent . Traiter les entr\u00e9es utilisateur pour influencer le mouvement des entit\u00e9s. Supprimer ou r\u00e9initialiser les entit\u00e9s en dehors des limites du jeu. Fonctionnalit\u00e9s principales M\u00e9thode update Cette m\u00e9thode parcourt toutes les entit\u00e9s ayant des composants pertinents (comme VelocityComponent et PositionComponent ) et met \u00e0 jour leurs positions. Exemple de code void MovementSystem::update(EntityManager &entityManager, NetworkManager &networkManager, float deltaTime, bool focus) { static float timer = 0.0f; timer += deltaTime; for (auto &entity : entityManager.entities) { auto *velocity = entity->getComponent<VelocityComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (velocity && position) { position->position.x += velocity->velocity.x * deltaTime; position->position.y += velocity->velocity.y * deltaTime; // Gestion des entit\u00e9s en dehors des limites du jeu if (position->position.x < 0 || position->position.x > 1920 || position->position.y < 0 || position->position.y > 1080) { entityManager.markForDeletion(entity->getId()); } } } entityManager.destroyMarkedEntities(); } Gestion des entr\u00e9es utilisateur Le syst\u00e8me traite \u00e9galement les entr\u00e9es utilisateur pour influencer la vitesse ou la direction : if (input && position && input->moveLeft) { position->position.x -= 200.0f * deltaTime; } Exemples d'Utilisation Initialisation et appel : cpp MovementSystem movementSystem; movementSystem.update(entityManager, networkManager, 0.016f, true); Suppression des entit\u00e9s hors limites : cpp if (position->position.x < 0 || position->position.x > 1920) { entityManager.markForDeletion(entity->getId()); } Interactions Avec PositionComponent : Met \u00e0 jour la position en fonction des calculs du syst\u00e8me. Avec VelocityComponent : Utilise la vitesse pour d\u00e9terminer les d\u00e9placements. Avec InputComponent : Permet aux utilisateurs d'influencer les mouvements des entit\u00e9s. Avec NetworkManager : Synchronise les mouvements des entit\u00e9s dans un environnement multijoueur. Le syst\u00e8me MovementSystem est essentiel pour g\u00e9rer les d\u00e9placements des entit\u00e9s, en combinant la logique des composants de position, de vitesse et des entr\u00e9es utilisateur.","title":"MovementSystem"},{"location":"systems/movement_system/#movementsystem","text":"","title":"MovementSystem"},{"location":"systems/movement_system/#introduction","text":"Le syst\u00e8me MovementSystem est responsable de la mise \u00e0 jour des positions des entit\u00e9s en fonction de leur vitesse et des entr\u00e9es utilisateur. Il joue un r\u00f4le cl\u00e9 dans le d\u00e9placement des entit\u00e9s dans le jeu.","title":"Introduction"},{"location":"systems/movement_system/#role-dans-lecs","text":"MovementSystem a pour r\u00f4le de : Calculer les nouvelles positions des entit\u00e9s en fonction de leur VelocityComponent . Traiter les entr\u00e9es utilisateur pour influencer le mouvement des entit\u00e9s. Supprimer ou r\u00e9initialiser les entit\u00e9s en dehors des limites du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"systems/movement_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/movement_system/#methode-update","text":"Cette m\u00e9thode parcourt toutes les entit\u00e9s ayant des composants pertinents (comme VelocityComponent et PositionComponent ) et met \u00e0 jour leurs positions.","title":"M\u00e9thode update"},{"location":"systems/movement_system/#exemple-de-code","text":"void MovementSystem::update(EntityManager &entityManager, NetworkManager &networkManager, float deltaTime, bool focus) { static float timer = 0.0f; timer += deltaTime; for (auto &entity : entityManager.entities) { auto *velocity = entity->getComponent<VelocityComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (velocity && position) { position->position.x += velocity->velocity.x * deltaTime; position->position.y += velocity->velocity.y * deltaTime; // Gestion des entit\u00e9s en dehors des limites du jeu if (position->position.x < 0 || position->position.x > 1920 || position->position.y < 0 || position->position.y > 1080) { entityManager.markForDeletion(entity->getId()); } } } entityManager.destroyMarkedEntities(); }","title":"Exemple de code"},{"location":"systems/movement_system/#gestion-des-entrees-utilisateur","text":"Le syst\u00e8me traite \u00e9galement les entr\u00e9es utilisateur pour influencer la vitesse ou la direction : if (input && position && input->moveLeft) { position->position.x -= 200.0f * deltaTime; }","title":"Gestion des entr\u00e9es utilisateur"},{"location":"systems/movement_system/#exemples-dutilisation","text":"Initialisation et appel : cpp MovementSystem movementSystem; movementSystem.update(entityManager, networkManager, 0.016f, true); Suppression des entit\u00e9s hors limites : cpp if (position->position.x < 0 || position->position.x > 1920) { entityManager.markForDeletion(entity->getId()); }","title":"Exemples d'Utilisation"},{"location":"systems/movement_system/#interactions","text":"Avec PositionComponent : Met \u00e0 jour la position en fonction des calculs du syst\u00e8me. Avec VelocityComponent : Utilise la vitesse pour d\u00e9terminer les d\u00e9placements. Avec InputComponent : Permet aux utilisateurs d'influencer les mouvements des entit\u00e9s. Avec NetworkManager : Synchronise les mouvements des entit\u00e9s dans un environnement multijoueur. Le syst\u00e8me MovementSystem est essentiel pour g\u00e9rer les d\u00e9placements des entit\u00e9s, en combinant la logique des composants de position, de vitesse et des entr\u00e9es utilisateur.","title":"Interactions"},{"location":"systems/parallax_system/","text":"ParallaxSystem Introduction ParallaxSystem est un syst\u00e8me con\u00e7u pour g\u00e9rer les effets de d\u00e9filement parallaxe dans le jeu. Il permet de cr\u00e9er une illusion de profondeur en d\u00e9pla\u00e7ant des arri\u00e8re-plans ou des textures \u00e0 des vitesses diff\u00e9rentes. R\u00f4le dans l'ECS ParallaxSystem est utilis\u00e9 pour : Mettre \u00e0 jour les positions des entit\u00e9s ayant un composant ParallaxComponent . Afficher des arri\u00e8re-plans dynamiques avec des mouvements fluides. Am\u00e9liorer l'exp\u00e9rience visuelle en simulant une profondeur. Fonctionnalit\u00e9s principales M\u00e9thode update La m\u00e9thode update ajuste la position des composants parallaxe en fonction de la vitesse d\u00e9finie et du temps \u00e9coul\u00e9. Code extrait de ParallaxSystem.cpp : void ParallaxSystem::update(EntityManager &entityManager, float deltaTime) { for (auto &entity : entityManager.entities) { auto *parallax = entity->getComponent<ParallaxComponent>(); if (parallax) { parallax->position.x += parallax->speed.x * deltaTime; parallax->position.y += parallax->speed.y * deltaTime; const auto textureSize = parallax->texture.getSize(); if (parallax->position.x < -static_cast<float>(textureSize.x) * parallax->scale.x) parallax->position.x = 0; if (parallax->position.y < -static_cast<float>(textureSize.y) * parallax->scale.y) parallax->position.y = 0; parallax->sprite.setPosition(parallax->position); } } } M\u00e9thode render La m\u00e9thode render dessine les textures parallaxe sur l'\u00e9cran, en remplissant les espaces n\u00e9cessaires pour un d\u00e9filement continu. Code extrait : void ParallaxSystem::render(sf::RenderWindow &window, EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *parallax = entity->getComponent<ParallaxComponent>(); if (parallax) { const auto textureSize = parallax->texture.getSize(); for (float x = parallax->position.x; x < static_cast<float>(window.getSize().x); x += textureSize.x * parallax->scale.x) { for (float y = parallax->position.y; y < static_cast<float>(window.getSize().y); y += textureSize.y * parallax->scale.y) { parallax->sprite.setPosition(x, y); window.draw(parallax->sprite); } } } } } Interactions Avec ParallaxComponent : Met \u00e0 jour les positions et les vitesses d\u00e9finies dans le composant. Avec RenderSystem : Travaille en compl\u00e9ment pour dessiner les arri\u00e8re-plans parallaxe. Exemples d'Utilisation Initialisation et mise \u00e0 jour : cpp float deltaTime = clock.restart().asSeconds(); parallaxSystem.update(entityManager, deltaTime); Affichage des arri\u00e8re-plans : cpp parallaxSystem.render(window, entityManager); Ajout d'un ParallaxComponent : cpp Entity &background = entityManager.createEntity(); background.addComponent<ParallaxComponent>(\"assets/background.png\", sf::Vector2f(1.0f, 1.0f), sf::Vector2f(-50.0f, 0.0f)); Fonctionnalit\u00e9s suppl\u00e9mentaires D\u00e9filement continu : Les textures sont automatiquement r\u00e9initialis\u00e9es pour un effet de boucle infinie. Support multi-texture : Permet de superposer plusieurs couches de parallaxe pour un effet plus riche. ParallaxSystem est essentiel pour am\u00e9liorer l'aspect visuel du jeu en cr\u00e9ant des arri\u00e8re-plans dynamiques et immersifs.","title":"ParallaxSystem"},{"location":"systems/parallax_system/#parallaxsystem","text":"","title":"ParallaxSystem"},{"location":"systems/parallax_system/#introduction","text":"ParallaxSystem est un syst\u00e8me con\u00e7u pour g\u00e9rer les effets de d\u00e9filement parallaxe dans le jeu. Il permet de cr\u00e9er une illusion de profondeur en d\u00e9pla\u00e7ant des arri\u00e8re-plans ou des textures \u00e0 des vitesses diff\u00e9rentes.","title":"Introduction"},{"location":"systems/parallax_system/#role-dans-lecs","text":"ParallaxSystem est utilis\u00e9 pour : Mettre \u00e0 jour les positions des entit\u00e9s ayant un composant ParallaxComponent . Afficher des arri\u00e8re-plans dynamiques avec des mouvements fluides. Am\u00e9liorer l'exp\u00e9rience visuelle en simulant une profondeur.","title":"R\u00f4le dans l'ECS"},{"location":"systems/parallax_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/parallax_system/#methode-update","text":"La m\u00e9thode update ajuste la position des composants parallaxe en fonction de la vitesse d\u00e9finie et du temps \u00e9coul\u00e9.","title":"M\u00e9thode update"},{"location":"systems/parallax_system/#code-extrait-de-parallaxsystemcpp","text":"void ParallaxSystem::update(EntityManager &entityManager, float deltaTime) { for (auto &entity : entityManager.entities) { auto *parallax = entity->getComponent<ParallaxComponent>(); if (parallax) { parallax->position.x += parallax->speed.x * deltaTime; parallax->position.y += parallax->speed.y * deltaTime; const auto textureSize = parallax->texture.getSize(); if (parallax->position.x < -static_cast<float>(textureSize.x) * parallax->scale.x) parallax->position.x = 0; if (parallax->position.y < -static_cast<float>(textureSize.y) * parallax->scale.y) parallax->position.y = 0; parallax->sprite.setPosition(parallax->position); } } }","title":"Code extrait de ParallaxSystem.cpp :"},{"location":"systems/parallax_system/#methode-render","text":"La m\u00e9thode render dessine les textures parallaxe sur l'\u00e9cran, en remplissant les espaces n\u00e9cessaires pour un d\u00e9filement continu.","title":"M\u00e9thode render"},{"location":"systems/parallax_system/#code-extrait","text":"void ParallaxSystem::render(sf::RenderWindow &window, EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *parallax = entity->getComponent<ParallaxComponent>(); if (parallax) { const auto textureSize = parallax->texture.getSize(); for (float x = parallax->position.x; x < static_cast<float>(window.getSize().x); x += textureSize.x * parallax->scale.x) { for (float y = parallax->position.y; y < static_cast<float>(window.getSize().y); y += textureSize.y * parallax->scale.y) { parallax->sprite.setPosition(x, y); window.draw(parallax->sprite); } } } } }","title":"Code extrait :"},{"location":"systems/parallax_system/#interactions","text":"Avec ParallaxComponent : Met \u00e0 jour les positions et les vitesses d\u00e9finies dans le composant. Avec RenderSystem : Travaille en compl\u00e9ment pour dessiner les arri\u00e8re-plans parallaxe.","title":"Interactions"},{"location":"systems/parallax_system/#exemples-dutilisation","text":"Initialisation et mise \u00e0 jour : cpp float deltaTime = clock.restart().asSeconds(); parallaxSystem.update(entityManager, deltaTime); Affichage des arri\u00e8re-plans : cpp parallaxSystem.render(window, entityManager); Ajout d'un ParallaxComponent : cpp Entity &background = entityManager.createEntity(); background.addComponent<ParallaxComponent>(\"assets/background.png\", sf::Vector2f(1.0f, 1.0f), sf::Vector2f(-50.0f, 0.0f));","title":"Exemples d'Utilisation"},{"location":"systems/parallax_system/#fonctionnalites-supplementaires","text":"D\u00e9filement continu : Les textures sont automatiquement r\u00e9initialis\u00e9es pour un effet de boucle infinie. Support multi-texture : Permet de superposer plusieurs couches de parallaxe pour un effet plus riche. ParallaxSystem est essentiel pour am\u00e9liorer l'aspect visuel du jeu en cr\u00e9ant des arri\u00e8re-plans dynamiques et immersifs.","title":"Fonctionnalit\u00e9s suppl\u00e9mentaires"},{"location":"systems/render_system/","text":"RenderSystem Introduction Le syst\u00e8me RenderSystem est charg\u00e9 d'afficher les entit\u00e9s sur l'\u00e9cran. Il utilise les composants graphiques comme RenderComponent et SpriteComponent pour dessiner les entit\u00e9s en fonction de leurs positions et de leurs propri\u00e9t\u00e9s visuelles. R\u00f4le dans l'ECS RenderSystem a pour r\u00f4le de : Dessiner les entit\u00e9s en utilisant leurs composants graphiques. Afficher les informations suppl\u00e9mentaires, telles que les noms d'utilisateur ou les barres de vie. Fournir une interface pour g\u00e9rer les mises \u00e0 jour visuelles en temps r\u00e9el. Fonctionnalit\u00e9s principales M\u00e9thode update Cette m\u00e9thode parcourt toutes les entit\u00e9s ayant des composants graphiques pertinents et les dessine \u00e0 l'\u00e9cran. Exemple de code void RenderSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *render = entity->getComponent<RenderComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (render && position) { render->shape.setPosition(position->position); window.draw(render->shape); } auto *username = entity->getComponent<UsernameComponent>(); if (username) { sf::Text text; text.setFont(font); text.setString(username->username); text.setCharacterSize(24); text.setFillColor(sf::Color::White); text.setPosition(position->position.x, position->position.y - 30); window.draw(text); } } } Affichage des barres d'information Le syst\u00e8me peut \u00e9galement afficher des \u00e9l\u00e9ments tels que les barres de vie ou des statistiques globales : void RenderSystem::displayBarInfos(EntityManager &entityManager) { sf::RectangleShape bar(sf::Vector2f(window.getSize().x, 70)); bar.setFillColor(sf::Color::Blue); window.draw(bar); } Exemples d'Utilisation Initialisation et appel : cpp sf::RenderWindow window(sf::VideoMode(1920, 1080), \"R-Type\"); RenderSystem renderSystem(window); renderSystem.update(entityManager); Affichage des noms d'utilisateur : cpp auto *username = entity->getComponent<UsernameComponent>(); if (username) { sf::Text text; text.setFont(font); text.setString(username->username); text.setCharacterSize(24); window.draw(text); } Interactions Avec RenderComponent : Utilis\u00e9 pour d\u00e9finir les propri\u00e9t\u00e9s graphiques des entit\u00e9s. Avec PositionComponent : Permet de dessiner les entit\u00e9s \u00e0 la position correcte. Avec UsernameComponent : Affiche les noms d'utilisateur au-dessus des entit\u00e9s. Avec HealthComponent : Ajoute des indicateurs graphiques pour les points de vie. Le syst\u00e8me RenderSystem est essentiel pour offrir une repr\u00e9sentation visuelle des entit\u00e9s et des interactions dans le jeu, en s'appuyant sur les composants graphiques pour afficher une exp\u00e9rience utilisateur coh\u00e9rente et immersive.","title":"RenderSystem"},{"location":"systems/render_system/#rendersystem","text":"","title":"RenderSystem"},{"location":"systems/render_system/#introduction","text":"Le syst\u00e8me RenderSystem est charg\u00e9 d'afficher les entit\u00e9s sur l'\u00e9cran. Il utilise les composants graphiques comme RenderComponent et SpriteComponent pour dessiner les entit\u00e9s en fonction de leurs positions et de leurs propri\u00e9t\u00e9s visuelles.","title":"Introduction"},{"location":"systems/render_system/#role-dans-lecs","text":"RenderSystem a pour r\u00f4le de : Dessiner les entit\u00e9s en utilisant leurs composants graphiques. Afficher les informations suppl\u00e9mentaires, telles que les noms d'utilisateur ou les barres de vie. Fournir une interface pour g\u00e9rer les mises \u00e0 jour visuelles en temps r\u00e9el.","title":"R\u00f4le dans l'ECS"},{"location":"systems/render_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/render_system/#methode-update","text":"Cette m\u00e9thode parcourt toutes les entit\u00e9s ayant des composants graphiques pertinents et les dessine \u00e0 l'\u00e9cran.","title":"M\u00e9thode update"},{"location":"systems/render_system/#exemple-de-code","text":"void RenderSystem::update(EntityManager &entityManager) { for (auto &entity : entityManager.entities) { auto *render = entity->getComponent<RenderComponent>(); auto *position = entity->getComponent<PositionComponent>(); if (render && position) { render->shape.setPosition(position->position); window.draw(render->shape); } auto *username = entity->getComponent<UsernameComponent>(); if (username) { sf::Text text; text.setFont(font); text.setString(username->username); text.setCharacterSize(24); text.setFillColor(sf::Color::White); text.setPosition(position->position.x, position->position.y - 30); window.draw(text); } } }","title":"Exemple de code"},{"location":"systems/render_system/#affichage-des-barres-dinformation","text":"Le syst\u00e8me peut \u00e9galement afficher des \u00e9l\u00e9ments tels que les barres de vie ou des statistiques globales : void RenderSystem::displayBarInfos(EntityManager &entityManager) { sf::RectangleShape bar(sf::Vector2f(window.getSize().x, 70)); bar.setFillColor(sf::Color::Blue); window.draw(bar); }","title":"Affichage des barres d'information"},{"location":"systems/render_system/#exemples-dutilisation","text":"Initialisation et appel : cpp sf::RenderWindow window(sf::VideoMode(1920, 1080), \"R-Type\"); RenderSystem renderSystem(window); renderSystem.update(entityManager); Affichage des noms d'utilisateur : cpp auto *username = entity->getComponent<UsernameComponent>(); if (username) { sf::Text text; text.setFont(font); text.setString(username->username); text.setCharacterSize(24); window.draw(text); }","title":"Exemples d'Utilisation"},{"location":"systems/render_system/#interactions","text":"Avec RenderComponent : Utilis\u00e9 pour d\u00e9finir les propri\u00e9t\u00e9s graphiques des entit\u00e9s. Avec PositionComponent : Permet de dessiner les entit\u00e9s \u00e0 la position correcte. Avec UsernameComponent : Affiche les noms d'utilisateur au-dessus des entit\u00e9s. Avec HealthComponent : Ajoute des indicateurs graphiques pour les points de vie. Le syst\u00e8me RenderSystem est essentiel pour offrir une repr\u00e9sentation visuelle des entit\u00e9s et des interactions dans le jeu, en s'appuyant sur les composants graphiques pour afficher une exp\u00e9rience utilisateur coh\u00e9rente et immersive.","title":"Interactions"},{"location":"systems/selection_system/","text":"SelectionSystem Introduction SelectionSystem g\u00e8re la s\u00e9lection des entit\u00e9s dans le jeu en d\u00e9tectant les clics de souris. Il modifie l'\u00e9tat des entit\u00e9s ayant un composant SelectionComponent pour indiquer si elles sont s\u00e9lectionn\u00e9es. R\u00f4le dans l'ECS SelectionSystem est utilis\u00e9 pour : D\u00e9tecter les clics de souris sur des entit\u00e9s interactives. Mettre \u00e0 jour l'\u00e9tat de s\u00e9lection des entit\u00e9s avec un composant SelectionComponent . Permettre des interactions utilisateur intuitives dans les menus ou sur les objets du jeu. Fonctionnalit\u00e9s principales M\u00e9thode update La m\u00e9thode update v\u00e9rifie si une entit\u00e9 a \u00e9t\u00e9 s\u00e9lectionn\u00e9e en fonction des \u00e9v\u00e9nements de clic de souris. Code extrait de SelectionSystem.cpp : void SelectionSystem::update(EntityManager &entityManager, const sf::Event::MouseButtonEvent &mouseEvent) { if (mouseEvent.button != sf::Mouse::Left) return; for (auto &i : entityManager.entities) { auto *spriteComponent = i->getComponent<SpriteComponent>(); auto *selectionComponent = i->getComponent<SelectionComponent>(); auto *rectangleShapeComponent = i->getComponent<RectangleShapeComponent>(); if (spriteComponent && selectionComponent) { selectionComponent->isSelected = spriteComponent->sprite.getGlobalBounds().contains(mouseEvent.x, mouseEvent.y); } if (rectangleShapeComponent && selectionComponent) { selectionComponent->isSelected = rectangleShapeComponent->shape.getGlobalBounds().contains(mouseEvent.x, mouseEvent.y); } } } Interactions Avec SelectionComponent : Modifie l'\u00e9tat isSelected en fonction des interactions utilisateur. Avec SpriteComponent : V\u00e9rifie si le clic de souris correspond \u00e0 un sprite. Avec RectangleShapeComponent : V\u00e9rifie si le clic de souris correspond \u00e0 une forme rectangulaire. Exemples d'Utilisation Initialisation et mise \u00e0 jour : cpp sf::Event event; if (event.type == sf::Event::MouseButtonPressed) { selectionSystem.update(entityManager, event.mouseButton); } Ajout d'un composant de s\u00e9lection : cpp Entity &button = entityManager.createEntity(); button.addComponent<SelectionComponent>(); V\u00e9rification de la s\u00e9lection : cpp auto *selection = entity.getComponent<SelectionComponent>(); if (selection && selection->isSelected) { std::cout << \"Entit\u00e9 s\u00e9lectionn\u00e9e !\" << std::endl; } Fonctionnalit\u00e9s suppl\u00e9mentaires Support multi-formes : Prend en charge les entit\u00e9s ayant des sprites ou des formes rectangulaires. Interactions utilisateur dynamiques : Facilite la cr\u00e9ation de menus et de syst\u00e8mes interactifs. SelectionSystem est un syst\u00e8me cl\u00e9 pour g\u00e9rer les interactions utilisateur en permettant la s\u00e9lection d'entit\u00e9s dans le jeu.","title":"SelectionSystem"},{"location":"systems/selection_system/#selectionsystem","text":"","title":"SelectionSystem"},{"location":"systems/selection_system/#introduction","text":"SelectionSystem g\u00e8re la s\u00e9lection des entit\u00e9s dans le jeu en d\u00e9tectant les clics de souris. Il modifie l'\u00e9tat des entit\u00e9s ayant un composant SelectionComponent pour indiquer si elles sont s\u00e9lectionn\u00e9es.","title":"Introduction"},{"location":"systems/selection_system/#role-dans-lecs","text":"SelectionSystem est utilis\u00e9 pour : D\u00e9tecter les clics de souris sur des entit\u00e9s interactives. Mettre \u00e0 jour l'\u00e9tat de s\u00e9lection des entit\u00e9s avec un composant SelectionComponent . Permettre des interactions utilisateur intuitives dans les menus ou sur les objets du jeu.","title":"R\u00f4le dans l'ECS"},{"location":"systems/selection_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/selection_system/#methode-update","text":"La m\u00e9thode update v\u00e9rifie si une entit\u00e9 a \u00e9t\u00e9 s\u00e9lectionn\u00e9e en fonction des \u00e9v\u00e9nements de clic de souris.","title":"M\u00e9thode update"},{"location":"systems/selection_system/#code-extrait-de-selectionsystemcpp","text":"void SelectionSystem::update(EntityManager &entityManager, const sf::Event::MouseButtonEvent &mouseEvent) { if (mouseEvent.button != sf::Mouse::Left) return; for (auto &i : entityManager.entities) { auto *spriteComponent = i->getComponent<SpriteComponent>(); auto *selectionComponent = i->getComponent<SelectionComponent>(); auto *rectangleShapeComponent = i->getComponent<RectangleShapeComponent>(); if (spriteComponent && selectionComponent) { selectionComponent->isSelected = spriteComponent->sprite.getGlobalBounds().contains(mouseEvent.x, mouseEvent.y); } if (rectangleShapeComponent && selectionComponent) { selectionComponent->isSelected = rectangleShapeComponent->shape.getGlobalBounds().contains(mouseEvent.x, mouseEvent.y); } } }","title":"Code extrait de SelectionSystem.cpp :"},{"location":"systems/selection_system/#interactions","text":"Avec SelectionComponent : Modifie l'\u00e9tat isSelected en fonction des interactions utilisateur. Avec SpriteComponent : V\u00e9rifie si le clic de souris correspond \u00e0 un sprite. Avec RectangleShapeComponent : V\u00e9rifie si le clic de souris correspond \u00e0 une forme rectangulaire.","title":"Interactions"},{"location":"systems/selection_system/#exemples-dutilisation","text":"Initialisation et mise \u00e0 jour : cpp sf::Event event; if (event.type == sf::Event::MouseButtonPressed) { selectionSystem.update(entityManager, event.mouseButton); } Ajout d'un composant de s\u00e9lection : cpp Entity &button = entityManager.createEntity(); button.addComponent<SelectionComponent>(); V\u00e9rification de la s\u00e9lection : cpp auto *selection = entity.getComponent<SelectionComponent>(); if (selection && selection->isSelected) { std::cout << \"Entit\u00e9 s\u00e9lectionn\u00e9e !\" << std::endl; }","title":"Exemples d'Utilisation"},{"location":"systems/selection_system/#fonctionnalites-supplementaires","text":"Support multi-formes : Prend en charge les entit\u00e9s ayant des sprites ou des formes rectangulaires. Interactions utilisateur dynamiques : Facilite la cr\u00e9ation de menus et de syst\u00e8mes interactifs. SelectionSystem est un syst\u00e8me cl\u00e9 pour g\u00e9rer les interactions utilisateur en permettant la s\u00e9lection d'entit\u00e9s dans le jeu.","title":"Fonctionnalit\u00e9s suppl\u00e9mentaires"},{"location":"systems/sound_system/","text":"SoundSystem Introduction SoundSystem g\u00e8re la lecture et la gestion des effets sonores dans le jeu. Il utilise les composants SoundComponent pour jouer des sons associ\u00e9s aux entit\u00e9s, contr\u00f4ler le volume et g\u00e9rer les r\u00e9p\u00e9titions. R\u00f4le dans l'ECS SoundSystem est utilis\u00e9 pour : Contr\u00f4ler les effets sonores associ\u00e9s aux entit\u00e9s. G\u00e9rer le volume global ou individuel des sons. Assurer la lecture des sons en boucle ou un nombre limit\u00e9 de fois. Fonctionnalit\u00e9s principales M\u00e9thode update La m\u00e9thode update v\u00e9rifie les composants SoundComponent des entit\u00e9s et joue les sons selon leurs configurations. Code extrait de SoundSystem.cpp : void SoundSystem::update(EntityManager &entityManager, int volume) { for (size_t i = 0; i < entityManager.entities.size(); i++) { auto &entity = entityManager.entities[i]; auto *soundComponent = entity->getComponent<SoundComponent>(); if (soundComponent && (soundComponent->timesPlayed < soundComponent->maxTimesPlayed || soundComponent->maxTimesPlayed == -1)) { soundComponent->sound.setVolume(volume); if (soundComponent->maxTimesPlayed != -1) { soundComponent->sound.play(); soundComponent->timesPlayed++; } else { if (!soundComponent->sound.getLoop()) { soundComponent->sound.setLoop(true); soundComponent->sound.play(); } } } } } Interactions Avec SoundComponent : Utilise les param\u00e8tres de volume, de boucle et de r\u00e9p\u00e9tition pour chaque son. Avec EntityManager : Parcourt les entit\u00e9s et applique les effets sonores d\u00e9finis. Exemples d'Utilisation Initialisation et mise \u00e0 jour : cpp int volume = 50; soundSystem.update(entityManager, volume); Ajout d'un composant sonore : cpp Entity &explosion = entityManager.createEntity(); explosion.addComponent<SoundComponent>(\"assets/explosion.wav\", 1); Contr\u00f4le du volume : cpp auto *sound = entity.getComponent<SoundComponent>(); if (sound) { sound->sound.setVolume(75.0f); } Fonctionnalit\u00e9s suppl\u00e9mentaires Gestion du volume global : Permet de contr\u00f4ler le volume de tous les sons simultan\u00e9ment. Support de la lecture en boucle : Configure les sons pour \u00eatre jou\u00e9s en boucle infinie si n\u00e9cessaire. SoundSystem enrichit l'exp\u00e9rience utilisateur en ajoutant une dimension sonore immersive, essentielle pour un gameplay captivant.","title":"SoundSystem"},{"location":"systems/sound_system/#soundsystem","text":"","title":"SoundSystem"},{"location":"systems/sound_system/#introduction","text":"SoundSystem g\u00e8re la lecture et la gestion des effets sonores dans le jeu. Il utilise les composants SoundComponent pour jouer des sons associ\u00e9s aux entit\u00e9s, contr\u00f4ler le volume et g\u00e9rer les r\u00e9p\u00e9titions.","title":"Introduction"},{"location":"systems/sound_system/#role-dans-lecs","text":"SoundSystem est utilis\u00e9 pour : Contr\u00f4ler les effets sonores associ\u00e9s aux entit\u00e9s. G\u00e9rer le volume global ou individuel des sons. Assurer la lecture des sons en boucle ou un nombre limit\u00e9 de fois.","title":"R\u00f4le dans l'ECS"},{"location":"systems/sound_system/#fonctionnalites-principales","text":"","title":"Fonctionnalit\u00e9s principales"},{"location":"systems/sound_system/#methode-update","text":"La m\u00e9thode update v\u00e9rifie les composants SoundComponent des entit\u00e9s et joue les sons selon leurs configurations.","title":"M\u00e9thode update"},{"location":"systems/sound_system/#code-extrait-de-soundsystemcpp","text":"void SoundSystem::update(EntityManager &entityManager, int volume) { for (size_t i = 0; i < entityManager.entities.size(); i++) { auto &entity = entityManager.entities[i]; auto *soundComponent = entity->getComponent<SoundComponent>(); if (soundComponent && (soundComponent->timesPlayed < soundComponent->maxTimesPlayed || soundComponent->maxTimesPlayed == -1)) { soundComponent->sound.setVolume(volume); if (soundComponent->maxTimesPlayed != -1) { soundComponent->sound.play(); soundComponent->timesPlayed++; } else { if (!soundComponent->sound.getLoop()) { soundComponent->sound.setLoop(true); soundComponent->sound.play(); } } } } }","title":"Code extrait de SoundSystem.cpp :"},{"location":"systems/sound_system/#interactions","text":"Avec SoundComponent : Utilise les param\u00e8tres de volume, de boucle et de r\u00e9p\u00e9tition pour chaque son. Avec EntityManager : Parcourt les entit\u00e9s et applique les effets sonores d\u00e9finis.","title":"Interactions"},{"location":"systems/sound_system/#exemples-dutilisation","text":"Initialisation et mise \u00e0 jour : cpp int volume = 50; soundSystem.update(entityManager, volume); Ajout d'un composant sonore : cpp Entity &explosion = entityManager.createEntity(); explosion.addComponent<SoundComponent>(\"assets/explosion.wav\", 1); Contr\u00f4le du volume : cpp auto *sound = entity.getComponent<SoundComponent>(); if (sound) { sound->sound.setVolume(75.0f); }","title":"Exemples d'Utilisation"},{"location":"systems/sound_system/#fonctionnalites-supplementaires","text":"Gestion du volume global : Permet de contr\u00f4ler le volume de tous les sons simultan\u00e9ment. Support de la lecture en boucle : Configure les sons pour \u00eatre jou\u00e9s en boucle infinie si n\u00e9cessaire. SoundSystem enrichit l'exp\u00e9rience utilisateur en ajoutant une dimension sonore immersive, essentielle pour un gameplay captivant.","title":"Fonctionnalit\u00e9s suppl\u00e9mentaires"}]}