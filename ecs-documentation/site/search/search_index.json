{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"components/a_component/","text":"AComponent Introduction Le composant AComponent est une classe de base abstraite qui sert de fondation pour tous les autres composants dans l'ECS. Il fournit une interface commune que tous les composants doivent impl\u00e9menter, assurant ainsi une structure coh\u00e9rente au sein du syst\u00e8me. Attributs Ce composant n'a pas d'attributs sp\u00e9cifiques car il est con\u00e7u pour \u00eatre une classe de base abstraite. Les composants qui en h\u00e9ritent ajouteront leurs propres attributs. R\u00f4le dans l'ECS AComponent est essentiel pour : Uniformiser les composants : Tous les composants partagent une interface commune. Faciliter la gestion des composants : Permet aux entit\u00e9s de stocker et manipuler des composants de mani\u00e8re polymorphique. Exemples d'Utilisation Voici un exemple de d\u00e9finition d'un composant qui h\u00e9rite de AComponent : #include \"AComponent.hpp\" class PositionComponent : public AComponent { public: float x, y; PositionComponent(float x, float y) : x(x), y(y) {} }; Ce mod\u00e8le montre comment des composants comme PositionComponent peuvent \u00eatre construits \u00e0 partir de AComponent pour ajouter leurs propres fonctionnalit\u00e9s et donn\u00e9es. Ce composant abstrait constitue la base de tous les autres et garantit une structure coh\u00e9rente dans le syst\u00e8me ECS.","title":"AComponent"},{"location":"components/a_component/#acomponent","text":"","title":"AComponent"},{"location":"components/a_component/#introduction","text":"Le composant AComponent est une classe de base abstraite qui sert de fondation pour tous les autres composants dans l'ECS. Il fournit une interface commune que tous les composants doivent impl\u00e9menter, assurant ainsi une structure coh\u00e9rente au sein du syst\u00e8me.","title":"Introduction"},{"location":"components/a_component/#attributs","text":"Ce composant n'a pas d'attributs sp\u00e9cifiques car il est con\u00e7u pour \u00eatre une classe de base abstraite. Les composants qui en h\u00e9ritent ajouteront leurs propres attributs.","title":"Attributs"},{"location":"components/a_component/#role-dans-lecs","text":"AComponent est essentiel pour : Uniformiser les composants : Tous les composants partagent une interface commune. Faciliter la gestion des composants : Permet aux entit\u00e9s de stocker et manipuler des composants de mani\u00e8re polymorphique.","title":"R\u00f4le dans l'ECS"},{"location":"components/a_component/#exemples-dutilisation","text":"Voici un exemple de d\u00e9finition d'un composant qui h\u00e9rite de AComponent : #include \"AComponent.hpp\" class PositionComponent : public AComponent { public: float x, y; PositionComponent(float x, float y) : x(x), y(y) {} }; Ce mod\u00e8le montre comment des composants comme PositionComponent peuvent \u00eatre construits \u00e0 partir de AComponent pour ajouter leurs propres fonctionnalit\u00e9s et donn\u00e9es. Ce composant abstrait constitue la base de tous les autres et garantit une structure coh\u00e9rente dans le syst\u00e8me ECS.","title":"Exemples d'Utilisation"},{"location":"components/bullet_id_component/","text":"BulletIdComponent Introduction Le composant BulletIdComponent identifie de mani\u00e8re unique chaque projectile dans le jeu. Il est essentiel pour g\u00e9rer les interactions et le suivi des projectiles sur la carte. Attributs id : Une cha\u00eene de caract\u00e8res unique qui identifie un projectile sp\u00e9cifique. Exemple d'attributs dans le fichier BulletIdComponent.hpp : class BulletIdComponent : public AComponent { public: std::string id; BulletIdComponent(const std::string &id) : id(id) {} }; R\u00f4le dans l'ECS BulletIdComponent est utilis\u00e9 pour : Identifier chaque projectile de mani\u00e8re unique dans le syst\u00e8me. Faciliter la gestion des collisions et des mises \u00e0 jour d'\u00e9tat des projectiles. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &bullet = entityManager.createEntity(); bullet.addComponent<BulletIdComponent>(\"bullet_1234\"); V\u00e9rification des collisions : Lors d'une collision, ce composant peut \u00eatre utilis\u00e9 pour r\u00e9cup\u00e9rer l'ID d'un projectile et appliquer les effets correspondants : cpp auto *bulletId = entity->getComponent<BulletIdComponent>(); if (bulletId) { std::cout << \"Projectile ID : \" << bulletId->id << std::endl; } Interactions Avec PositionComponent : Permet de suivre la position du projectile. Avec VelocityComponent : G\u00e8re la trajectoire du projectile en fonction de sa vitesse. Le composant BulletIdComponent joue un r\u00f4le crucial dans la gestion des projectiles, en offrant un identifiant unique pour chaque instance.","title":"BulletIdComponent"},{"location":"components/bullet_id_component/#bulletidcomponent","text":"","title":"BulletIdComponent"},{"location":"components/bullet_id_component/#introduction","text":"Le composant BulletIdComponent identifie de mani\u00e8re unique chaque projectile dans le jeu. Il est essentiel pour g\u00e9rer les interactions et le suivi des projectiles sur la carte.","title":"Introduction"},{"location":"components/bullet_id_component/#attributs","text":"id : Une cha\u00eene de caract\u00e8res unique qui identifie un projectile sp\u00e9cifique.","title":"Attributs"},{"location":"components/bullet_id_component/#exemple-dattributs-dans-le-fichier-bulletidcomponenthpp","text":"class BulletIdComponent : public AComponent { public: std::string id; BulletIdComponent(const std::string &id) : id(id) {} };","title":"Exemple d'attributs dans le fichier BulletIdComponent.hpp :"},{"location":"components/bullet_id_component/#role-dans-lecs","text":"BulletIdComponent est utilis\u00e9 pour : Identifier chaque projectile de mani\u00e8re unique dans le syst\u00e8me. Faciliter la gestion des collisions et des mises \u00e0 jour d'\u00e9tat des projectiles.","title":"R\u00f4le dans l'ECS"},{"location":"components/bullet_id_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &bullet = entityManager.createEntity(); bullet.addComponent<BulletIdComponent>(\"bullet_1234\"); V\u00e9rification des collisions : Lors d'une collision, ce composant peut \u00eatre utilis\u00e9 pour r\u00e9cup\u00e9rer l'ID d'un projectile et appliquer les effets correspondants : cpp auto *bulletId = entity->getComponent<BulletIdComponent>(); if (bulletId) { std::cout << \"Projectile ID : \" << bulletId->id << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/bullet_id_component/#interactions","text":"Avec PositionComponent : Permet de suivre la position du projectile. Avec VelocityComponent : G\u00e8re la trajectoire du projectile en fonction de sa vitesse. Le composant BulletIdComponent joue un r\u00f4le crucial dans la gestion des projectiles, en offrant un identifiant unique pour chaque instance.","title":"Interactions"},{"location":"components/ennemy_id_component/","text":"EnnemyIdComponent Introduction Le composant EnnemyIdComponent identifie chaque ennemi de mani\u00e8re unique dans le syst\u00e8me. Il est utilis\u00e9 pour distinguer les ennemis et suivre leur \u00e9tat dans le jeu. Attributs id : Une cha\u00eene de caract\u00e8res unique qui repr\u00e9sente l'identifiant de l'ennemi. Exemple d'attributs dans le fichier EnnemyIdComponent.hpp : class EnnemyIdComponent : public AComponent { public: std::string id; EnnemyIdComponent(const std::string &id) : id(id) {} }; R\u00f4le dans l'ECS EnnemyIdComponent est utilis\u00e9 pour : Identifier chaque ennemi de mani\u00e8re unique dans le jeu. Faciliter la gestion des ennemis, comme le suivi de leur \u00e9tat ou l'application des d\u00e9g\u00e2ts. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &enemy = entityManager.createEntity(); enemy.addComponent<EnnemyIdComponent>(\"enemy_001\"); Identification dans un syst\u00e8me : Lors de l'ex\u00e9cution d'un syst\u00e8me, ce composant peut \u00eatre utilis\u00e9 pour identifier les ennemis : cpp auto *enemyId = entity->getComponent<EnnemyIdComponent>(); if (enemyId) { std::cout << \"Enemy ID : \" << enemyId->id << std::endl; } Interactions Avec HealthComponent : Permet de g\u00e9rer les points de vie de l'ennemi. Avec PositionComponent : Suit la position de l'ennemi sur la carte. Avec RenderComponent : G\u00e8re l'affichage de l'ennemi \u00e0 l'\u00e9cran. Le composant EnnemyIdComponent est essentiel pour la gestion des ennemis dans le jeu, offrant un moyen simple de les identifier et de les manipuler.","title":"EnnemyIdComponent"},{"location":"components/ennemy_id_component/#ennemyidcomponent","text":"","title":"EnnemyIdComponent"},{"location":"components/ennemy_id_component/#introduction","text":"Le composant EnnemyIdComponent identifie chaque ennemi de mani\u00e8re unique dans le syst\u00e8me. Il est utilis\u00e9 pour distinguer les ennemis et suivre leur \u00e9tat dans le jeu.","title":"Introduction"},{"location":"components/ennemy_id_component/#attributs","text":"id : Une cha\u00eene de caract\u00e8res unique qui repr\u00e9sente l'identifiant de l'ennemi.","title":"Attributs"},{"location":"components/ennemy_id_component/#exemple-dattributs-dans-le-fichier-ennemyidcomponenthpp","text":"class EnnemyIdComponent : public AComponent { public: std::string id; EnnemyIdComponent(const std::string &id) : id(id) {} };","title":"Exemple d'attributs dans le fichier EnnemyIdComponent.hpp :"},{"location":"components/ennemy_id_component/#role-dans-lecs","text":"EnnemyIdComponent est utilis\u00e9 pour : Identifier chaque ennemi de mani\u00e8re unique dans le jeu. Faciliter la gestion des ennemis, comme le suivi de leur \u00e9tat ou l'application des d\u00e9g\u00e2ts.","title":"R\u00f4le dans l'ECS"},{"location":"components/ennemy_id_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &enemy = entityManager.createEntity(); enemy.addComponent<EnnemyIdComponent>(\"enemy_001\"); Identification dans un syst\u00e8me : Lors de l'ex\u00e9cution d'un syst\u00e8me, ce composant peut \u00eatre utilis\u00e9 pour identifier les ennemis : cpp auto *enemyId = entity->getComponent<EnnemyIdComponent>(); if (enemyId) { std::cout << \"Enemy ID : \" << enemyId->id << std::endl; }","title":"Exemples d'Utilisation"},{"location":"components/ennemy_id_component/#interactions","text":"Avec HealthComponent : Permet de g\u00e9rer les points de vie de l'ennemi. Avec PositionComponent : Suit la position de l'ennemi sur la carte. Avec RenderComponent : G\u00e8re l'affichage de l'ennemi \u00e0 l'\u00e9cran. Le composant EnnemyIdComponent est essentiel pour la gestion des ennemis dans le jeu, offrant un moyen simple de les identifier et de les manipuler.","title":"Interactions"},{"location":"components/health_component/","text":"HealthComponent Introduction Le composant HealthComponent est utilis\u00e9 pour g\u00e9rer les points de vie des entit\u00e9s dans le jeu. Il permet de suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s et de d\u00e9terminer si elles sont vivantes ou doivent \u00eatre supprim\u00e9es. Attributs health : Un entier repr\u00e9sentant les points de vie actuels de l'entit\u00e9. maxHealth : Un entier repr\u00e9sentant le nombre maximum de points de vie que l'entit\u00e9 peut avoir. Exemple d'attributs dans le fichier HealthComponent.hpp : class HealthComponent : public AComponent { public: int health; int maxHealth; HealthComponent(int health, int maxHealth) : health(health), maxHealth(maxHealth) {} }; R\u00f4le dans l'ECS HealthComponent est utilis\u00e9 pour : Suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s, telles que les joueurs, ennemis ou objets destructibles. D\u00e9clencher des \u00e9v\u00e9nements lorsque la sant\u00e9 atteint 0 (par exemple, destruction ou mort). G\u00e9rer les soins ou autres modifications des points de vie. Exemples d'Utilisation Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<HealthComponent>(100, 100); R\u00e9duction des points de vie : cpp auto *health = entity->getComponent<HealthComponent>(); if (health) { health->health -= 10; if (health->health <= 0) { entityManager.markForDeletion(entity->getId()); } } Soin d'une entit\u00e9 : cpp if (health && health->health < health->maxHealth) { health->health += 20; if (health->health > health->maxHealth) { health->health = health->maxHealth; } } Interactions Avec RenderComponent : Pour afficher une barre de vie ou d'autres indicateurs visuels. Avec MessageSystem : Pour synchroniser l'\u00e9tat de sant\u00e9 entre les clients et le serveur. Le composant HealthComponent est un \u00e9l\u00e9ment cl\u00e9 pour g\u00e9rer l'\u00e9tat des entit\u00e9s dans le jeu, permettant des interactions dynamiques et r\u00e9actives bas\u00e9es sur leur sant\u00e9.","title":"HealthComponent"},{"location":"components/health_component/#healthcomponent","text":"","title":"HealthComponent"},{"location":"components/health_component/#introduction","text":"Le composant HealthComponent est utilis\u00e9 pour g\u00e9rer les points de vie des entit\u00e9s dans le jeu. Il permet de suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s et de d\u00e9terminer si elles sont vivantes ou doivent \u00eatre supprim\u00e9es.","title":"Introduction"},{"location":"components/health_component/#attributs","text":"health : Un entier repr\u00e9sentant les points de vie actuels de l'entit\u00e9. maxHealth : Un entier repr\u00e9sentant le nombre maximum de points de vie que l'entit\u00e9 peut avoir.","title":"Attributs"},{"location":"components/health_component/#exemple-dattributs-dans-le-fichier-healthcomponenthpp","text":"class HealthComponent : public AComponent { public: int health; int maxHealth; HealthComponent(int health, int maxHealth) : health(health), maxHealth(maxHealth) {} };","title":"Exemple d'attributs dans le fichier HealthComponent.hpp :"},{"location":"components/health_component/#role-dans-lecs","text":"HealthComponent est utilis\u00e9 pour : Suivre l'\u00e9tat de sant\u00e9 des entit\u00e9s, telles que les joueurs, ennemis ou objets destructibles. D\u00e9clencher des \u00e9v\u00e9nements lorsque la sant\u00e9 atteint 0 (par exemple, destruction ou mort). G\u00e9rer les soins ou autres modifications des points de vie.","title":"R\u00f4le dans l'ECS"},{"location":"components/health_component/#exemples-dutilisation","text":"Ajout \u00e0 une entit\u00e9 : cpp Entity &player = entityManager.createEntity(); player.addComponent<HealthComponent>(100, 100); R\u00e9duction des points de vie : cpp auto *health = entity->getComponent<HealthComponent>(); if (health) { health->health -= 10; if (health->health <= 0) { entityManager.markForDeletion(entity->getId()); } } Soin d'une entit\u00e9 : cpp if (health && health->health < health->maxHealth) { health->health += 20; if (health->health > health->maxHealth) { health->health = health->maxHealth; } }","title":"Exemples d'Utilisation"},{"location":"components/health_component/#interactions","text":"Avec RenderComponent : Pour afficher une barre de vie ou d'autres indicateurs visuels. Avec MessageSystem : Pour synchroniser l'\u00e9tat de sant\u00e9 entre les clients et le serveur. Le composant HealthComponent est un \u00e9l\u00e9ment cl\u00e9 pour g\u00e9rer l'\u00e9tat des entit\u00e9s dans le jeu, permettant des interactions dynamiques et r\u00e9actives bas\u00e9es sur leur sant\u00e9.","title":"Interactions"},{"location":"components/input_component/","text":"","title":"InputComponent"},{"location":"components/network_component/","text":"","title":"NetworkComponent"},{"location":"components/position_component/","text":"","title":"PositionComponent"},{"location":"components/render_component/","text":"","title":"RenderComponent"},{"location":"components/sprite_component/","text":"","title":"SpriteComponent"},{"location":"components/username_component/","text":"","title":"UsernameComponent"},{"location":"components/velocity_component/","text":"","title":"VelocityComponent"},{"location":"overview/architecture/","text":"Architecture de l'ECS (Entity Component System) L'architecture de l'Entity Component System (ECS) mise en place dans ce projet vise \u00e0 fournir une base modulaire et flexible pour le d\u00e9veloppement du jeu R-Type. Voici une vue d'ensemble de sa structure et de ses \u00e9l\u00e9ments principaux. Vue g\u00e9n\u00e9rale L'ECS est compos\u00e9 de trois \u00e9l\u00e9ments principaux : Entity (Entit\u00e9s) : Repr\u00e9sentent les objets du jeu. Component (Composants) : Fournissent les donn\u00e9es associ\u00e9es \u00e0 une entit\u00e9. System (Syst\u00e8mes) : Contiennent la logique qui manipule les composants des entit\u00e9s. Cette architecture permet une forte d\u00e9couplage entre les donn\u00e9es et la logique, ce qui rend le syst\u00e8me facilement extensible et maintenable. Organisation du projet Voici la structure du dossier ECS : client/ecs/ \u251c\u2500\u2500 Entity.cpp \u251c\u2500\u2500 Entity.hpp \u251c\u2500\u2500 EntityManager.cpp \u251c\u2500\u2500 EntityManager.hpp \u251c\u2500\u2500 NetworkManager.cpp \u251c\u2500\u2500 NetworkManager.hpp \u251c\u2500\u2500 component \u2502 \u251c\u2500\u2500 AComponent.hpp \u2502 \u251c\u2500\u2500 BulletIdComponent.hpp \u2502 \u251c\u2500\u2500 EnnemyIdComponent.hpp \u2502 \u251c\u2500\u2500 HealthComponent.hpp \u2502 \u251c\u2500\u2500 InputComponent.hpp \u2502 \u251c\u2500\u2500 NetworkComponent.hpp \u2502 \u251c\u2500\u2500 PositionComponent.hpp \u2502 \u251c\u2500\u2500 RenderComponent.hpp \u2502 \u251c\u2500\u2500 SpriteComponent.hpp \u2502 \u251c\u2500\u2500 UsernameComponent.hpp \u2502 \u2514\u2500\u2500 VelocityComponent.hpp \u2514\u2500\u2500 system \u251c\u2500\u2500 InputSystem.cpp \u251c\u2500\u2500 InputSystem.hpp \u251c\u2500\u2500 MessageSystem.cpp \u251c\u2500\u2500 MessageSystem.hpp \u251c\u2500\u2500 MovementSystem.cpp \u251c\u2500\u2500 MovementSystem.hpp \u251c\u2500\u2500 RenderSystem.cpp \u2514\u2500\u2500 RenderSystem.hpp Entit\u00e9s et gestion Les entit\u00e9s sont g\u00e9r\u00e9es par la classe EntityManager . Chaque entit\u00e9 poss\u00e8de un identifiant unique (ID) qui permet de les suivre et de les manipuler dans les diff\u00e9rents syst\u00e8mes. Composants Les composants sont des structures de donn\u00e9es pures, sans logique, qui d\u00e9crivent les caract\u00e9ristiques des entit\u00e9s. Ils sont organis\u00e9s dans le dossier component et incluent des \u00e9l\u00e9ments tels que : PositionComponent : G\u00e8re la position spatiale d'une entit\u00e9. HealthComponent : Suivi des points de vie. RenderComponent : Gestion de l'affichage. Syst\u00e8mes Les syst\u00e8mes impl\u00e9mentent la logique du jeu en interagissant avec les composants. Ils incluent des syst\u00e8mes tels que : InputSystem : G\u00e8re les entr\u00e9es utilisateur. MovementSystem : Met \u00e0 jour les positions des entit\u00e9s en fonction des vitesses. RenderSystem : Dessine les entit\u00e9s \u00e0 l'\u00e9cran. Gestion r\u00e9seau La classe NetworkManager g\u00e8re les communications entre le client et le serveur, permettant de synchroniser l'\u00e9tat des entit\u00e9s \u00e0 travers le r\u00e9seau. Points forts de l'architecture Flexibilit\u00e9 : Facile \u00e0 \u00e9tendre avec de nouveaux composants ou syst\u00e8mes. Modularit\u00e9 : D\u00e9couplage des donn\u00e9es et de la logique. Performance : Appropri\u00e9 pour un traitement efficace en boucle de jeu.","title":"Architecture"},{"location":"overview/architecture/#architecture-de-lecs-entity-component-system","text":"L'architecture de l'Entity Component System (ECS) mise en place dans ce projet vise \u00e0 fournir une base modulaire et flexible pour le d\u00e9veloppement du jeu R-Type. Voici une vue d'ensemble de sa structure et de ses \u00e9l\u00e9ments principaux.","title":"Architecture de l'ECS (Entity Component System)"},{"location":"overview/architecture/#vue-generale","text":"L'ECS est compos\u00e9 de trois \u00e9l\u00e9ments principaux : Entity (Entit\u00e9s) : Repr\u00e9sentent les objets du jeu. Component (Composants) : Fournissent les donn\u00e9es associ\u00e9es \u00e0 une entit\u00e9. System (Syst\u00e8mes) : Contiennent la logique qui manipule les composants des entit\u00e9s. Cette architecture permet une forte d\u00e9couplage entre les donn\u00e9es et la logique, ce qui rend le syst\u00e8me facilement extensible et maintenable.","title":"Vue g\u00e9n\u00e9rale"},{"location":"overview/architecture/#organisation-du-projet","text":"Voici la structure du dossier ECS : client/ecs/ \u251c\u2500\u2500 Entity.cpp \u251c\u2500\u2500 Entity.hpp \u251c\u2500\u2500 EntityManager.cpp \u251c\u2500\u2500 EntityManager.hpp \u251c\u2500\u2500 NetworkManager.cpp \u251c\u2500\u2500 NetworkManager.hpp \u251c\u2500\u2500 component \u2502 \u251c\u2500\u2500 AComponent.hpp \u2502 \u251c\u2500\u2500 BulletIdComponent.hpp \u2502 \u251c\u2500\u2500 EnnemyIdComponent.hpp \u2502 \u251c\u2500\u2500 HealthComponent.hpp \u2502 \u251c\u2500\u2500 InputComponent.hpp \u2502 \u251c\u2500\u2500 NetworkComponent.hpp \u2502 \u251c\u2500\u2500 PositionComponent.hpp \u2502 \u251c\u2500\u2500 RenderComponent.hpp \u2502 \u251c\u2500\u2500 SpriteComponent.hpp \u2502 \u251c\u2500\u2500 UsernameComponent.hpp \u2502 \u2514\u2500\u2500 VelocityComponent.hpp \u2514\u2500\u2500 system \u251c\u2500\u2500 InputSystem.cpp \u251c\u2500\u2500 InputSystem.hpp \u251c\u2500\u2500 MessageSystem.cpp \u251c\u2500\u2500 MessageSystem.hpp \u251c\u2500\u2500 MovementSystem.cpp \u251c\u2500\u2500 MovementSystem.hpp \u251c\u2500\u2500 RenderSystem.cpp \u2514\u2500\u2500 RenderSystem.hpp","title":"Organisation du projet"},{"location":"overview/architecture/#entites-et-gestion","text":"Les entit\u00e9s sont g\u00e9r\u00e9es par la classe EntityManager . Chaque entit\u00e9 poss\u00e8de un identifiant unique (ID) qui permet de les suivre et de les manipuler dans les diff\u00e9rents syst\u00e8mes.","title":"Entit\u00e9s et gestion"},{"location":"overview/architecture/#composants","text":"Les composants sont des structures de donn\u00e9es pures, sans logique, qui d\u00e9crivent les caract\u00e9ristiques des entit\u00e9s. Ils sont organis\u00e9s dans le dossier component et incluent des \u00e9l\u00e9ments tels que : PositionComponent : G\u00e8re la position spatiale d'une entit\u00e9. HealthComponent : Suivi des points de vie. RenderComponent : Gestion de l'affichage.","title":"Composants"},{"location":"overview/architecture/#systemes","text":"Les syst\u00e8mes impl\u00e9mentent la logique du jeu en interagissant avec les composants. Ils incluent des syst\u00e8mes tels que : InputSystem : G\u00e8re les entr\u00e9es utilisateur. MovementSystem : Met \u00e0 jour les positions des entit\u00e9s en fonction des vitesses. RenderSystem : Dessine les entit\u00e9s \u00e0 l'\u00e9cran.","title":"Syst\u00e8mes"},{"location":"overview/architecture/#gestion-reseau","text":"La classe NetworkManager g\u00e8re les communications entre le client et le serveur, permettant de synchroniser l'\u00e9tat des entit\u00e9s \u00e0 travers le r\u00e9seau.","title":"Gestion r\u00e9seau"},{"location":"overview/architecture/#points-forts-de-larchitecture","text":"Flexibilit\u00e9 : Facile \u00e0 \u00e9tendre avec de nouveaux composants ou syst\u00e8mes. Modularit\u00e9 : D\u00e9couplage des donn\u00e9es et de la logique. Performance : Appropri\u00e9 pour un traitement efficace en boucle de jeu.","title":"Points forts de l'architecture"},{"location":"overview/introduction/","text":"Introduction Bienvenue dans la documentation de l'architecture ECS (Entity Component System) du projet R-Type. Cette documentation a pour but de fournir une vue claire et d\u00e9taill\u00e9e de la structure et du fonctionnement de l'ECS, une partie centrale de notre moteur de jeu. Qu'est-ce qu'un ECS ? L'Entity Component System est un mod\u00e8le architectural con\u00e7u pour fournir une approche modulaire et flexible \u00e0 la cr\u00e9ation de jeux. Il repose sur trois piliers principaux : Entit\u00e9s : Des conteneurs d'identit\u00e9, sans logique ou donn\u00e9es. Composants : Des structures de donn\u00e9es attach\u00e9es aux entit\u00e9s pour d\u00e9crire leurs caract\u00e9ristiques. Syst\u00e8mes : Des modules logiques qui op\u00e8rent sur des ensembles d'entit\u00e9s ayant des composants pertinents. Cette approche s'\u00e9loigne des mod\u00e8les traditionnels orient\u00e9s objet en d\u00e9coupant clairement les donn\u00e9es et la logique, ce qui facilite l'\u00e9volution du code et la r\u00e9utilisation des composants. Objectifs de l'ECS dans ce projet Notre ECS est con\u00e7u pour r\u00e9pondre aux besoins sp\u00e9cifiques du jeu R-Type, notamment : Flexibilit\u00e9 : Faciliter l'ajout de nouvelles fonctionnalit\u00e9s. Performance : Optimiser les traitements gr\u00e2ce \u00e0 une architecture orient\u00e9e sur les donn\u00e9es. Modularit\u00e9 : Permettre une s\u00e9paration claire des responsabilit\u00e9s entre les diff\u00e9rents syst\u00e8mes. Contenu de cette documentation Voici les sections principales que vous trouverez dans cette documentation : Overview : Une vue d'ensemble de l'architecture et des concepts fondamentaux. Components : D\u00e9tails des diff\u00e9rents composants impl\u00e9ment\u00e9s. Systems : Explication des syst\u00e8mes et de leurs interactions avec les composants. Managers : Pr\u00e9sentation des gestionnaires principaux, comme l'EntityManager et le NetworkManager. Pourquoi cette documentation est importante Une documentation bien structur\u00e9e est essentielle pour : Permettre aux nouveaux d\u00e9veloppeurs de se familiariser rapidement avec le projet. Assurer une maintenance efficace du code. Faciliter les \u00e9volutions futures en fournissant une vue d'ensemble claire des interactions entre les diff\u00e9rents \u00e9l\u00e9ments.","title":"Introduction"},{"location":"overview/introduction/#introduction","text":"Bienvenue dans la documentation de l'architecture ECS (Entity Component System) du projet R-Type. Cette documentation a pour but de fournir une vue claire et d\u00e9taill\u00e9e de la structure et du fonctionnement de l'ECS, une partie centrale de notre moteur de jeu.","title":"Introduction"},{"location":"overview/introduction/#quest-ce-quun-ecs","text":"L'Entity Component System est un mod\u00e8le architectural con\u00e7u pour fournir une approche modulaire et flexible \u00e0 la cr\u00e9ation de jeux. Il repose sur trois piliers principaux : Entit\u00e9s : Des conteneurs d'identit\u00e9, sans logique ou donn\u00e9es. Composants : Des structures de donn\u00e9es attach\u00e9es aux entit\u00e9s pour d\u00e9crire leurs caract\u00e9ristiques. Syst\u00e8mes : Des modules logiques qui op\u00e8rent sur des ensembles d'entit\u00e9s ayant des composants pertinents. Cette approche s'\u00e9loigne des mod\u00e8les traditionnels orient\u00e9s objet en d\u00e9coupant clairement les donn\u00e9es et la logique, ce qui facilite l'\u00e9volution du code et la r\u00e9utilisation des composants.","title":"Qu'est-ce qu'un ECS ?"},{"location":"overview/introduction/#objectifs-de-lecs-dans-ce-projet","text":"Notre ECS est con\u00e7u pour r\u00e9pondre aux besoins sp\u00e9cifiques du jeu R-Type, notamment : Flexibilit\u00e9 : Faciliter l'ajout de nouvelles fonctionnalit\u00e9s. Performance : Optimiser les traitements gr\u00e2ce \u00e0 une architecture orient\u00e9e sur les donn\u00e9es. Modularit\u00e9 : Permettre une s\u00e9paration claire des responsabilit\u00e9s entre les diff\u00e9rents syst\u00e8mes.","title":"Objectifs de l'ECS dans ce projet"},{"location":"overview/introduction/#contenu-de-cette-documentation","text":"Voici les sections principales que vous trouverez dans cette documentation : Overview : Une vue d'ensemble de l'architecture et des concepts fondamentaux. Components : D\u00e9tails des diff\u00e9rents composants impl\u00e9ment\u00e9s. Systems : Explication des syst\u00e8mes et de leurs interactions avec les composants. Managers : Pr\u00e9sentation des gestionnaires principaux, comme l'EntityManager et le NetworkManager.","title":"Contenu de cette documentation"},{"location":"overview/introduction/#pourquoi-cette-documentation-est-importante","text":"Une documentation bien structur\u00e9e est essentielle pour : Permettre aux nouveaux d\u00e9veloppeurs de se familiariser rapidement avec le projet. Assurer une maintenance efficace du code. Faciliter les \u00e9volutions futures en fournissant une vue d'ensemble claire des interactions entre les diff\u00e9rents \u00e9l\u00e9ments.","title":"Pourquoi cette documentation est importante"}]}